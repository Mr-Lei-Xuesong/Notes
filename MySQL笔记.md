# 概述

## 简介

|      名称      |                             全称                             |               简称               |
| :------------: | :----------------------------------------------------------: | :------------------------------: |
|     数据库     |            存储数据的仓库，数据是有组织的进行存储            |          DataBase（DB）          |
| 数据库管理系统 |                  操纵和管理数据库的大型软件                  | DataBase ManagementSystem (DBMS) |
|      SQL       | 操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准 | Structured Query Language (SQL)  |

## 客户端连接

```
mysql  [-h 127.0.0.1]  [-P 3306]  -u root -p
```

> **参数：**
>
> * -h：MySQL服务所在的主机IP
> * -P：MySQL服务端口号，默认3306	
> * -u：MySQL数据库用户名
> * -p：MySQL数据库用户名对应的密码

## 数据模型

> **关系型数据库(RDBMS)**
>
> * 概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库
>
> **而所谓二维表，指的是由行和列组成的表**。MySQL、Oracle、DB2、SQLServer这些都是属于关系型数据库，里面都是基于二维表存储数据的。简单说，基于二维表存储数据的数据库就成为关系型数据库，不是基于二维表存储数据的数据库，就是非关系型数据库。
>
> * 特点：
>   * 使用表存储数据，格式统一，便于维护
>   * 使用SQL语言操作，标准统一，使用方便

# SQL

> 全称 Structured  Query Language，结构化查询语言。操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准

## SQL通用语法

> 1. SQL语句可以单行或多行书写，以分号结尾
> 2. SQL语句可以使用空格/缩进来增强语句的可读性
> 3. MySQL数据库的SQL语句不区分大小写，**关键字建议使用大写**
> 4. 注释
>    * 单行注释：-- 注释内容  或  # 注释内容(MySQL特有)
>    * 多行注释：/* 注释内容 */

## SQL分类

| 分类 |            全称            |                         说明                         |
| :--: | :------------------------: | :--------------------------------------------------: |
| DDL  |  Data Definition Language  |  数据定义语言，用来定义数据库对象(数据库，表，字段)  |
| DML  | Data Manipulation Language |    数据操作语言，用来对数据库表中的数据进行增删改    |
| DQL  |    Data Query Language     |        数据查询语言，用来查询数据库中表的记录        |
| DCL  |   Data Control Language    | 数据控制语言，用来创建数据库用户、控制数据的访问权限 |

## DDL

### 数据库操作

1. 查询所有数据库

   ```sql
   show databases;
   ```

2. 查询当前数据库

   ```sql
   select database();
   ```

3. 创建数据库

   ```sql
   create database [if not exists] 数据库名 [default charset 字符集] [collate 排序规则];
   ```

4. 删除数据库

   ```sql
   drop database [if exists] 数据库名;
   ```

5. 切换数据库

   ```sql
   use 数据库名;
   ```

### 表操作

#### 查询创建

1. 查询当前数据库所有表

   ```sql
   show tables;
   ```

2. 查看指定表结构

   ```sql
   desc 表名;
   ```

3. 查询指定表的建表语句

   ```sql
   show create table 表名;
   ```

4. 创建表结构

   ```sql
   create table 表名(
   	字段1 字段1类型 [comment 字段1注释],
   	字段2 字段2类型 [comment 字段2注释],
        .....
        字段n 字段n类型 [comment 字段n注释]
   )[comment 表注释];
   ```

   > **`注意`**：**最后一个字段后面没有逗号**

#### 数据类型

> MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型

1. 数值类型

   |   类型    |  大小  |                 有符号(SIGNED)范围                 |                 无符号(UNSIGNED)范围                 |        描述        |
   | :-------: | :----: | :------------------------------------------------: | :--------------------------------------------------: | :----------------: |
   |  tinyint  | 1byte  |                     (-128,127)                     |                       (0,255)                        |      小整数值      |
   | smallint  | 2bytes |                   (-32768,32767)                   |                      (0,65535)                       |      大整数值      |
   | mediumint | 3bytes |                 (-8388608,8388607)                 |                     (0,16777215)                     |      大整数值      |
   |    int    | 4bytes |              (-2147483648,2147483647)              |                    (0,4294967295)                    |      大整数值      |
   |  bigint   | 8bytes |                   (-2^63,2^63-1)                   |                      (0,2^64-1)                      |     极大整数值     |
   |   float   | 4bytes |       (-3.402823466E+38,3.402823466351E+38)        |         0和(1.175494351E-38,3.402823466E+38)         |   单精度浮点数值   |
   |  double   | 8bytes | (-1.7976931348623157E+308,1.7976931348623157E+308) | 0和(2.2250738585072016E-308,1.7976931348623157E+308) |   双精度浮点数值   |
   |  decimal  |        |             依赖于M(精度)和D(标度)的值             |              依赖于M(精度)和D(标度)的值              | 小数值(精确定点数) |

2. 字符串类型

   |    类型    |         大小         |             描述             |
   | :--------: | :------------------: | :--------------------------: |
   |    char    |     0-255 bytes      |   定长字符串(需要指定长度)   |
   |  varchar   |    0-65535 bytes     |   变长字符串(需要指定长度)   |
   |  tinyblob  |     0-255 bytes      | 不超过255个字符的二进制数据  |
   |  tinytext  |     0-255 bytes      |         短文本字符串         |
   |    blob    |    0-65 535 bytes    |    二进制形式的长文本数据    |
   |    text    |    0-65 535 bytes    |          长文本数据          |
   | mediumblob |  0-16 777 215 bytes  | 二进制形式的中等长度文本数据 |
   | mediumtext |  0-16 777 215 bytes  |       中等长度文本数据       |
   |  longblob  | 0-4 294 967 295 byte |   二进制形式的极大文本数据   |
   |  longtext  | -4 294 967 295 bytes |         极大文本数据         |

   > **char 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关。而varchar是变长字符串，指定的长度为最大占用长度。相对来说，char的性能会更高些**

3. 日期时间类型

   |   类型    | 大小 |                   范围                    |        格式        |           描述           |
   | :-------: | :--: | :---------------------------------------: | :----------------: | :----------------------: |
   |   date    |  3   |          1000-01-01 至9999-12-31          |     YYYY-MM-DD     |          日期值          |
   |   time    |  3   |          -838:59:59 至838:59:59           |      HH:MM:SS      |     时间值或持续时间     |
   |   year    |  1   |               1901 至 2155                |        YYYY        |          年份值          |
   | datetime  |  8   | 1000-01-01 00:00:00 至9999-12-31 23:59:5  | YYYY-MM-DDHH:MM:SS |     混合日期和时间值     |
   | timestamp |  4   | 1970-01-01 00:00:01 至2038-01-19 03:14:07 | YYYY-MM-DDHH:MM:SS | 混合日期和时间值，时间戳 |

#### 修改

1. 添加字段

   ```sql
   alter table 表名 add 字段名 类型(长度) [comment 注释] [约束];
   ```

2. 修改数据类型

   ```sql
   alter table 表名 modify 字段名 新数据类型(长度);
   ```

3. 修改字段名和字段类型

   ```sql
   alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];
   ```

4. 删除字段

   ```sql
   alter table 表名 drop 字段名;
   ```

5. 修改表名

   ```sql
   alter table 表名 rename to 新表名;
   ```

#### 删除

1. 删除表

   ```sql
   drop table [if exists] 表名;
   ```

2. 删除指定表，并重新创建表

   ```sql
   truncate table 表名;
   ```

   > **`注意`**：**在删除表的时候，表种的全部数据也都会被删除**

## DML

### 添加数据

1. 给指定字段添加数据

   ```sql
   insert into 表名(字段名1,字段名2,...) values (值1,值2,...);
   ```

2. 给全部字段添加数据

   ```sql
   insert into 表名 values(值1,值2,...);
   ```

3. 批量添加数据

   ```sql
   insert into 表名(字段名1,字段名2,...) values (值1,值2,...),(值1,值2,...),(值1,值2,...);
   ```

   > **`注意`**：
   >
   > * **插入数据时，指定的字段顺序需要与值得顺序一一对应**
   > * **字符串和日期类型数据应该包含在引号中**
   > * **插入的数据大小，应该在字段的规定范围内**

### 修改数据

```sql
update 表名 set 字段名1=值1,字段名2=值2,... [where 条件];
```

> **`注意`**：
>
> * **修改语句的条件可以有，也可以没有，`如果没有条件，则会修改整张表的所有数据`。**

### 删除数据

```sql
delete from 表名 [where 条件];
```

> **`注意：`**
>
> * **delete语句的条件可以有，也可以没有，`如果没有条件，则会删除整张表的所有数据`。**
> * **delete语句不能删除某一个字段的值(可以使用update，将该字段值置为null即可)。**

## DQL

### 基本语法

> **select** 
>
> ​	**字段列表**
> **from**
>
> ​	**表名列表**
>
> **where**
>
> ​	**条件列表**
> **group by**
>
> ​	**分组字段列表**
>
> **having**
>
> ​	**分组后条件列表**
> **order by**
>
> ​	**排序字段列表**
>
> **limit**
>
> ​	**分页参数**

### 基础查询

1. 查询多个字段

   ```sql
   select 字段1,字段2,... from 表名;
   ```

   ```sql
   select * from 表名;
   ```

   > **`注意`**：*** 号代表查询所有字段，在实际开发中尽量少用(不直观，影响效率)**

2. 字段设置别名

   ```sql
   select 字段1 [as 别名1],字段2 [as 别名2],... from 表名;
   ```

   ```sql
   select 字段1 [别名1],字段2 [别名2],... from 表名;
   ```

3. 去除重复记录

   ```sql
   select distinct 字段列表 from 表名;
   ```

### 条件查询

1. 语法

   ```sql
   select 字段列表 from 表名 where 条件列表;
   ```

2. 条件

   * 常用的比较运算符如下：

     |     比较运算符      |                   功能                   |
     | :-----------------: | :--------------------------------------: |
     |          >          |                   大于                   |
     |         >=          |                 大于等于                 |
     |          <          |                   小于                   |
     |         <=          |                 小于等于                 |
     |          =          |                   等于                   |
     |       <>或!=        |                  不等于                  |
     | between ... and ... |      在某个范围之内(含最小、最大值)      |
     |       in(...)       |       在in之后的列表中的值，多选一       |
     |     like 占位符     | 模糊匹配(_匹配单个字符，%匹配任意个字符) |
     |       is null       |                  是Null                  |

   * 常用的逻辑运算符如下：

     | 逻辑运算符 |            功能            |
     | :--------: | :------------------------: |
     | and 或 &&  |   并且(多个条件同时成立)   |
     | or 或 \|\| | 或者(多个条件任意一个成立) |
     |  not 或 !  |          非，不是          |

### 聚合函数

1. 介绍

   ```
   将一列数据作为一个整体，进行纵向计算
   ```

2. 常见的聚合函数

   | 函数  |   功能   |
   | :---: | :------: |
   | count | 统计数量 |
   |  max  |  最大值  |
   |  min  |  最小值  |
   |  avg  |  平均值  |
   |  sum  |   求和   |

3. 语法

   ```sql
   select  聚合函数(字段列表) from 表名;
   ```

   > **`注意`**：**Null值是不参与所有的聚合函数运算的**

### 分组查询

1. 语法

   ```sql
   select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件];
   ```

2. where和having区别

   * **执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。**

   * **判断条件不同：where不能对聚合函数进行判断，而having可以。**

     > **`注意`**：
     >
     > * **分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。**
     > * **执行顺序：where>聚合函数>having**
     > * **支持多字段分组，具体语法为：group by 字段1,字段2**

### 排序查询

1. 语法

   ```sql
   select 字段列表 from 表名 order by 字段1 排序方式1,字段2 排序方式2,...;
   ```

2. 排序方式

   * ASC：升序(默认值)
   * DESC：降序

   > **`注意`**：
   >
   > * **如果是升序，可以不指定排序方式ASC;**
   > * **如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。**

### 分页查询

1. 语法

   ```sql
   select 字段列表 from 表名 limit 起始索引，查询记录数;
   ```

   > **`注意`**：
   >
   > * **起始索引从0开始，`起始索引=(查询页码 - 1) * 每页显示记录数`。**
   > * **分页查询是数据库的方言，不同的数据库有不同的实现**
   > * **如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10**

### 执行顺序

![](.\img\178.jpg)

## DCL

### 管理用户

1. 查询用户

   ```sql
   select * from mysql.user;
   ```

2. 创建用户

   ```sql
   create user '用户名'@'主机名' identified by '密码';
   ```

3. 修改用户密码

   ```sql
   alter user '用户名'@'主机名' identified with mysql_native_password by '新密码';
   ```

4. 删除用户

   ```sql
   drop user '用户名'@'主机名';
   ```

> **`注意`：**
>
> * **在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户**
> * **主机名可以使用%通配**

### 权限控制

|        权限        |        说明        |
| :----------------: | :----------------: |
| ALL,ALL PRIVILEGES |      所有权限      |
|       SELECT       |      查询数据      |
|       INSERT       |      插入数据      |
|       UPDATE       |      修改数据      |
|       DELETE       |      删除数据      |
|       ALTER        |       修改表       |
|        DROP        | 删除数据库/表/视图 |
|       CREATE       |   创建数据库/表    |

1. 查询权限

   ```sql
   show grants for '用户名'@'主机名';
   ```

2. 授予权限

   ```sql
   grants 权限列表 on 数据库名.表名 to '用户名'@'主机名';
   ```

3. 撤销权限

   ```sql
   revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名';
   ```

> **`注意`：**
>
> * **多个权限之间，使用逗号分隔**
> * **授权时，数据库名和表名可以使用 * 进行通配，代表所有**

# 函数

> 函数是指一段可以直接被另一段程序调用的程序或代码。也就意味着，这一段程序或代码在MySQL中已经给我们提供了，我们要做的就是在合适的业务场景调用对应的函数完成对应的业务需求即可

## 字符串函数

|           函数           |                             功能                             |
| :----------------------: | :----------------------------------------------------------: |
|   concat(s1,s2,...,sn)   |         字符串拼接，将s1，s2，...sn拼接成一个字符串          |
|        lower(str)        |                   将字符串str全部转为小写                    |
|        upper(str)        |                   将字符串str全部转为大写                    |
|     lpad(str,n,pad)      | 左填充，用字符串pad对str的左边进行填充，总数达到n个字符串长度 |
|     rpad(str,n,pad)      | 右填充，用字符串pad对str的右边进行填充，总数达到n个字符串长度 |
|        trim(str)         |                去掉字符串str头部和尾部的空格                 |
| substring(str,start,len) |       返回从字符串str从start位置起的len个长度的字符串        |

## 数值函数

|    函数    |                功能                |
| :--------: | :--------------------------------: |
|  ceil(x)   |              向上取整              |
|  floor(x)  |              向下取整              |
|  mod(x,y)  |            返回x/y的模             |
|   rand()   |         返回0~1内的随机数          |
| round(x,y) | 求参数x的四舍五入的值，保留y位小数 |

## 日期函数

|               函数                |                       功能                        |
| :-------------------------------: | :-----------------------------------------------: |
|             curdate()             |                   返回当前日期                    |
|             curtime()             |                   返回当前时间                    |
|               now()               |                返回当前日期和时间                 |
|            year(date)             |                获取指定date的年份                 |
|            month(date)            |                获取指定date的月份                 |
|             day(date)             |                获取指定date的日期                 |
| date_add(date,INTERVAL expr type) | 返回一个日期/时间值加上一个时间间隔expr后的时间值 |
|       datediff(date1,date2)       |    返回起始时间date1和结束时间date2之间的天数     |
|     date_format(date,format)      |            不同的格式显示日期/时间数据            |

## 流程函数

|                             函数                             |                             功能                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|                        if(value,t,f)                         |             如果value为true，则返回t，否则返回f              |
|                    ifnull(value1,value2)                     |         如果value1不为空，返回value1，否则返回value2         |
|   case when [value1] then [result1] ... else [default] end   |   如果value1为true，返回result1，...否则返回default默认值    |
| case [expr] when [value1] then [result-1] ... else [default] end | 如果expr的值等于value1，返回result1，... 否则返回default默认值 |

# 约束

## 概述

> 概念：**约束是作用于表中字段上的规则，用于限制存储在表中的数据**
>
> 目的：**保证数据库中数据的正确性、有效性和完整性**
>
> 分类：
>
> |             约束             |                             描述                             |     关键字      |
> | :--------------------------: | :----------------------------------------------------------: | :-------------: |
> |         **非空约束**         |                **限制该字段的数据不能为null**                |  **not null**   |
> |         **唯一约束**         |          **保证该字段的所有数据都是唯一、不重复的**          |   **unique**    |
> |         **主键约束**         |         **主键是一行数据的唯一标识，要求非空且唯一**         | **primary key** |
> |         **默认约束**         |      **保存数据时，如果未指定该字段的值，则采用默认值**      |   **default**   |
> | **检查约束(8.0.16版本之后)** |                 **保证字段值满足某一个条件**                 |    **check**    |
> |         **外键约束**         | **用来让两张表的数据之间建立连接，保证数据的一致性和完整性** | **foreign key** |
>
> **`注意`：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束**

## 外键约束

### 语法

1. 添加外键

   ```sql
   create table 表名(
   	字段名 数据类型,
        ...
       [constraint] [外键名称] foreign key (外键字段名) references 主表 (主表列名)
   );
   ```

   ```sql
   alter table 表名 add constraint 外键名称 foreign key (外键字段名) references 主表 (主表列名);
   ```

2. 删除外键

   ```sql
   alter table 表名 drop foreign key 外键名称;
   ```

3. **删除/更新行为**

   > **添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除/更新行为**
   >
   > |       行为        |                             说明                             |
   > | :---------------: | :----------------------------------------------------------: |
   > |     no action     | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。(与restrict 一致)默认行为 |
   > |     restrict      | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新。(与no action 一致)默认行为 |
   > | **cascade(级联)** | **当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除/更新外键所在子表的记录** |
   > |   **set null**    | **当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为Null(这就要求该外键允许取值为Null)** |
   > |  **set default**  | **父表有变更时，子表将外键列设置成一个默认的值(Innodb不支持)** |
   >
   > **`语法`**
   >
   > ```sql
   > alter table 表名 add constraint 外键名称 foreign key (外键字段) references 主表名 (主表字段名) on update 行为 on delete 行为
   > ```

# 多表查询

## 多表关系

> 项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：
>
> * 一对多(多对一)
>   * 案例：部门 与 员工 的关系
>   * 关系：一个部门对应多个员工，一个员工对应一个部门
>   * 实现：在多的一方建立外键，指向一的一方的主键
> * 多对多
>   * 案例：学生 与 课程 的关系
>   * 关系：一个学生可以选修多门课程，一门课程也可以供给多个学生选择
>   * 实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键
> * 一对一
>   * 案例：用户 与 用户详情 的关系
>   * 关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率
>   * 实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(unique)

> **`笛卡尔积`: 笛卡尔乘积是指在数学中，两个集合A集合和 B集合的所有组合情况。**

## 概述

> **分类：**
>
> * 连接查询
>   * 内连接：相当于查询A、B交集部分数据
>   * 外连接：
>     * 左外连接：查询左表所有数据，以及两张表交集部分数据
>     * 右外连接：查询右表所有数据，以及两张表交集部分数据
>   * 自连接：当前表与自身的连接查询，自连接必须使用表别名
> * 子查询

## 内连接

> ![](.\img\179.jpg)
>
> **内连接查询的是两张表交集部分的数据。**
>
> **内连接的语法分为两种：隐式内连接、显示内连接。**

1. 隐式内连接

   ```sql
   select 字段列表 from 表1,表2 where 条件 ...;
   ```

2. 显示内连接

   ```sql
   select 字段列表 from 表1 [inner] join 表2 on 连接条件 ...;
   ```

## 外连接

1. 左外连接

   ```sql
   select 字段列表 from 表1 left [outer] join 表2 on 条件 ...;
   ```

   > 左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据

2. 右外连接

   ```sql
   select 字段列表 from 表1 right [outer] join 表2 on 条件 ...;
   ```

   > 右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据

> **`注意`：左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接**

## 自连接

### 自连接查询

> 自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次。
>
> **而对于自连接查询，可以是内连接查询，也可以是外连接查询**

* 自连接查询

  ```sql
  select 字段列表 from 表A 别名A join 表A 别名B on 条件 ...;
  ```

  > **`注意`：在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底是哪一张表的字段**

### 联合查询

> 对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集

* 联合查询

  ```sql
  select 字段列表 from 表A ...
  union [all]
  select 字段列表 from 表B ...;
  ```

  > * **对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致**
  > * **union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重**

## 子查询

### 概述

> 1. 概念
>
>    SQL语句中嵌套select语句，称为嵌套查询，又称子查询。
>
>    ```sql
>    select * from t1 where column1=(select column1 from t2);
>    ```
>
>    **子查询外部的语句可以是 insert / update / delete / select任何一个**
>
> 2. 分类
>
>    根据子查询结果不同，分为：
>
>    * 标量子查询(子查询结果为单个值)
>    * 列子查询(子查询结果为一列)
>    * 行子查询(子查询结果为一行)
>    * 表子查询(子查询结果为多行多列)
>
>    根据子查询位置，分为：
>
>    * where之后
>    * from之后
>    * select之后

### 标量子查询

> **子查询返回的结果是单个值(数字、字符串、日期等)**，最简单的形式，这种子查询称为标量子查询
>
> 常用的操作符：=、<>、>、>=、<、<=

### 列子查询

> **子查询返回的结果是一列(可以是多行)**，这种查询称为列子查询
>
> 常用的操作符：in、not in、any、some、all
>
> | 操作符 |                  描述                  |
> | :----: | :------------------------------------: |
> |   in   |      在指定的集合范围之内，多选一      |
> | not in |         不在指定的集合范围之内         |
> |  any   |  子查询返回列表中，有任意一个满足即可  |
> |  some  | 与any等同，使用some的地方都可以使用any |
> |  all   |    子查询返回列表的所有值都必须满足    |

### 行子查询

> 子查询返回的结果是一行(可以是多列)，这种子查询称为行子查询
>
> 常用的操作符：=、<>、in、not in

### 表子查询

> 子查询返回的结果是多行多列，这种子查询称为表子查询
>
> 常用的操作符：in

# 事务

## 简介

> **事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。**

> **`注意`：默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务。**

## 事务操作

### 控制事务一

1. 查看/设置事务提交方式

   ```sql
   select @@autocommit;
   
   set @@autocommit=0;
   -- 1是自动提交，0是手动提交
   ```

2. 提交事务

   ```sql
   commit
   ```

3. 回滚事务

   ```sql
   rollback
   ```

> **`注意`：上述的这种方式，我们是修改了事务的自动提交行为，把默认的自定提交修改为了手动提交，此时我们执行的DML语句都不会提交，都需要手动的执行commit进行提交。**

### 控制事务二

1. 开启事务

   ```sql
   start transaction 或 begin
   ```

2. 提交事务

   ```sql
   commit
   ```

3. 回滚事务

   ```sql
   rollback
   ```

> eg：
>
> ```sql
> -- 开启事务
> start transaction;
> 
> -- 1.查询张三余额
> select * from account where name='张三';
> 
> -- 2.张三的余额减少1000
> update account set money=money-1000 where name='张三';
> 
> -- 3.李四的余额增加1000
> update account set money=money+1000 where name='李四';
> 
> -- 如果正常执行完毕，则提交事务
> commit;
> 
> -- 如果执行过程中报错，则回滚事务
> -- rollback;
> ```

## 事务四大特性(ACID)

* **`原子性(Atomicity)`**：**事务是不可分割的最小操作单元，要么全部成功，要么全部失败。**
* **`一致性(Consistency)`**：**事务完成时，必须使所有的数据都保持一致状态。**
* **`隔离性(Isolation)`**：**数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。**
* **`持久性(Durability)`**：**事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。**

## 并发事务问题

* **`脏读`**：**一个事务读到另外一个事务还没提交的数据。**

  * 比如B读取到了A未提交的数据

  ![](.\img\180.jpg)

* **`不可重复读`**：**一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。**

  * 事务A两次读取同一条记录，但是读取到的数据却是不一样的

  ![](.\img\181.jpg)

* **`幻读`**：**一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了“幻影”。**

  ![](.\img\182.jpg)

## 事务隔离级别

> 为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：
>
> |               隔离级别               |   脏读    | 不可重复读 | 幻读 |
> | :----------------------------------: | :-------: | :--------: | :--: |
> |      Read uncommitted(读未提交)      | ×(未解决) |     ×      |  ×   |
> |       Read commited(读已提交)        |  √(解决)  |     ×      |  ×   |
> | Repeatable Read(可重复读，MySQL默认) |     √     |     √      |  ×   |
> |         Serializable(串行化)         |     √     |     √      |  √   |
>
> 1. 查看事务隔离级别
>
>    ```sql
>    select @@transaction_isolation;
>    ```
>
> 2. 设置事务隔离级别
>
>    ```sql
>    set [session|global] transaction isolation level [read uncommitted|read committed|repeatable read|serializable]
>    ```
>
> **`注意`：事务隔离级别越高，数据越安全，但是性能越低。**

# 存储引擎

## MySQL体系结构

![](.\img\183.jpg)

1. 连接层

   > 最上层是一些客户端和链接服务，包含本地Sock通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限

2. 服务层

   > 第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。

3. 引擎层

   > 存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的

4. 存储层

   > 数据存储层，主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。

## 存储引擎介绍

>  **`存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型`。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。**

1. 创建表时指定存储引擎

   ```sql
   create table 表名(
   	字段1 字段1类型 [comment 字段1注释],
        ...
        字段N 字段N类型 [comment 字段N注释]
   )engine=InnoDB [comment 表注释];
   ```

2. 查询当前数据库支持的存储引擎

   ```sql
   show engines;
   ```

## 存储引擎特点

### InnoDB

1. 介绍

   > InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的MySQL 存储引擎。

2. 特点
   * DML操作遵循ACID模型，支持**事务**
   * **行级锁**，提高并发访问性能
   * 支持**外键Foreign key 约束**，保证数据的完整性和正确性

3. 文件

   > xxx.ibd：xxx代表的是表名，InnoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构(frm-早期的，sdi-新版的)、数据和索引

4. 逻辑存储结构

   ![](.\img\184.jpg)

   * 表空间：InnoDB存储引擎逻辑结构的最高层，idb文件其实就是表空间文件，在表空间中可以包含多个Segment段
   * 段：表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。InnoDB在对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区
   * 区：区是表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页
   * 页：页是组成区的最小单元，**页也是InnoDB存储引擎磁盘管理的最小单元**，每个页的大小默认为16Kb，为了保证页的连续性，InnoDB存储引擎每次从磁盘申请4-5个区
   * 行：InnoDB存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段。

### MyISAM

1. 介绍

   > MyISAM是MySQL早期的默认存储引擎

2. 特点
   * 不支持事务，不支持外键
   * 支持**表锁**，不支持行锁
   * 访问速度快
3. 文件
   * xxx.sdi：存储表结构信息
   * xxx.MYD：存储数据
   * xxx.MYI：存储索引

### Memory

1. 介绍

   > Memory引擎的表数据是存储在内存中的，由于受到硬件问题或断电问题的影响，只能将这些表作为临时表或缓存使用

2. 特点
   * 内存存放
   * hash索引(默认)
3. 文件
   
   * xxx.sdi：存储表结构信息

### 区别及特点

|     特点     |      InnoDB       | MyISAM | Memory |
| :----------: | :---------------: | :----: | :----: |
|   存储限制   |       64TB        |   有   |   有   |
|   事务安全   |     **支持**      |   -    |   -    |
|    锁机制    |     **行锁**      |  表锁  |  表锁  |
|  B+tree索引  |       支持        |  支持  |  支持  |
|   Hash索引   |         -         |   -    |  支持  |
|   全文索引   | 支持(5.6版本之后) |  支持  |   -    |
|   空间使用   |        高         |   低   |  N/A   |
|   内存使用   |        高         |   低   |  中等  |
| 批量插入速度 |        低         |   高   |   高   |
|   支持外键   |     **支持**      |   -    |   -    |

> 面试题：
>
> InnoDB与MyISAM引擎的区别？
>
> * InnoDB引擎，支持事务，而MyISAM不支持
> * InnoDB引擎，支持行锁和表锁，而MyISAM仅支持表锁，不支持行锁
> * InnoDB引擎，支持外键，而MyISAM不支持

## 存储引擎选择

> 在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。
>
> * InnoDB：是MySQL的默认存储引擎，支持事务，外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。
> * MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。
> * Memory：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数的安全性。

# 索引

## 索引概述

1. 介绍

   > **`索引(Index)是帮助MySQL高效获取数据的数据结构(有序)`**。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

2. 特点

   |                            优势                             |                             劣势                             |
   | :---------------------------------------------------------: | :----------------------------------------------------------: |
   |           提高数据检索的效率，降低数据库的IO成本            |                    索引列也是要占用空间的                    |
   | 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗 | 索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行insert、update、delete时，效率降低 |

## 索引结构

### 概述

> MySQL的**索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构**，主要包含以下几种：
>
> |      索引结构       |                             描述                             |
> | :-----------------: | :----------------------------------------------------------: |
> |     B+Tree索引      |          最常见的索引类型，大部分引擎都支持B+树索引          |
> |      Hash索引       | 底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询 |
> |  R-Tree(空间索引)   | 空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 |
> | Full-text(全文索引) | 是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene，Solar，ES |
>
> 上述是MySQL中所支持的所有的索引结构，接下来，我们再来看看不同的存储引擎对于索引结构的支持情况。
>
> |    索引    |     InnoDB      | MyISAM | Memory |
> | :--------: | :-------------: | :----: | :----: |
> | B+Tree索引 |      支持       |  支持  |  支持  |
> |  Hash索引  |     不支持      | 不支持 |  支持  |
> | R-Tree索引 |     不支持      |  支持  | 不支持 |
> | Full-text  | 5.6版本之后支持 |  支持  | 不支持 |
>
> > **`注意`**：**我们平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引**

### 二叉树

> 假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：
>
> <img src=".\img\185.jpg" style="zoom: 50%;" />
>
> 如果主键是顺序插入的，则会形成一个单向链表，结构如下：
>
> <img src=".\img\186.jpg" style="zoom:50%;" />
>
> 所以，如果选择二叉树作为索引结构，会存在以下缺点:
>
> * 顺序插入时，会形成一个链表，查询性能大大降低
> * 大数据量情况下，层级较深，检索速度慢

### B-Tree

> B树是一种多叉路平衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。以一颗最大度数(max-degree)为5(5阶)的B-Tree树为例，这个B树每个节点最多存储4个Key，5个指针
>
> ![](.\img\187.jpg)
>
> > **树的度数指的是一个节点的子节点个数**
>
> 特点：
>
> * 5阶的B树，每一个节点最多存储4个Key，对应5个指针。
> * 一旦节点存储的Key数量到达5，就会裂变，中间元素向上分裂。
> * **`在B树中，非叶子节点和叶子节点都会存放数据。`**

### B+Tree

> B+Tree是B-Tree的变种，我们以一颗最大度数(max-degree)为4(4阶)的B+Tree为例
>
> ![](.\img\188.jpg)
>
> * 绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。
> * 红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。
>
> **B+Tree与B-Tree相比，主要有以下三点区别**：
>
> * **`所有的数据都会出现在叶子节点`**
> * **`叶子节点形成一个单向链表`**
> * **`非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的`**

> **MySQL索引数据结构对经典的B+Tree进行了优化。在原有B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序**
>
> ![](.\img\189.jpg)

### Hash

> 1. 简介
>
>    哈希索引就是采用一定的Hash算法，将键值换算成新的Hash值，映射到对应的槽位上，然后存储在Hash表中。
>
>    ![](.\img\190.jpg)
>
>    如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了**Hash冲突(也称为hash碰撞)，可以通过链表来解决**。
>
>    ![](.\img\191.jpg)
>
> 2. 特点：
>    * **`Hash索引只能用于对等比较(=，in)，不支持范围查询(between，>，<，...)`**
>    * 无法利用索引完成排序操作
>    * 查询效率高，通常(不存在Hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+Tree索引
>
> 3. 存储引擎支持
>
>    在MySQL中，支持Hash索引的是Memory存储引擎。而InnoDB中具有自适应Hash功能，Hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的

> **为什么InnoDB存储引擎选择使用B+Tree索引结构？**
>
> * **`相对于二叉树，层级更少，搜索效率高`**
> * **`对于B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低`**
> * **`相对于Hash索引，B+Tree支持范围匹配及排序操作`**

## 索引分类

### 索引分类

|   分类   |                         含义                         |           特点           |  关键字  |
| :------: | :--------------------------------------------------: | :----------------------: | :------: |
| 主键索引 |               针对于表中主键创建的索引               | 默认自动创建，只能有一个 | primary  |
| 唯一索引 |           避免同一个表中某数据列中的值重复           |        可以有多个        |  unique  |
| 常规索引 |                   快速定位特定数据                   |        可以有多个        |          |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 |        可以有多个        | fulltext |

### 聚集索引&二级索引(辅助索引)

> 在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：
>
> |           分类            |                             含义                             |         特点         |
> | :-----------------------: | :----------------------------------------------------------: | :------------------: |
> | 聚集索引(Clustered Index) | **将数据存储与索引放到一块，索引结构的叶子节点保存了行数据** | 必须有，而且只有一个 |
> | 二级索引(Secondary Index) | **将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键** |     可以存在多个     |
>
> 聚集索引选取规则：
>
> * 如果存在主键，主键索引就是聚集索引。
> * 如果不存在主键，将使用第一个唯一(unique)索引作为聚集索引。
> * 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。
>
> 聚集索引和二级索引的具体结构如下：
>
> ![](.\img\192.jpg)
>
> * 聚集索引的叶子节点下挂的是这一行的数据。
> * 二级索引的叶子节点下挂的是该字段值对应的主键值。
>
> > **`回表查询`**：**这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询**

## 索引语法

1. 创建索引

   ```sql
   create [unique|fulltext] index 索引名称 on 表名 (字段1,字段2,...);
   ```

   > 一个索引是可以关联多个字段的
   >
   > 一个索引只关联一个字段称之为**单列索引**
   >
   > 一个索引关联了多个字段称之为**联合索引或组合索引**

2. 查看索引

   ```sql
   show index from 表名;
   ```

3. 删除索引

   ```sql
   drop index 索引名称 on 表名;
   ```

## SQL性能分析

### SQL执行频率

```sql
show global|session status like 'Com_______';
```

> session 是查看当前会话
>
> global 是查看全局数据
>
> **Com后面七个下划线**

### 慢查询日志

> 慢查询日志记录了所有执行时间超过指定参数(long_query_time，单位：秒)的所有SQL语句日志
>
> MySQL的慢查询日志默认没有开启，可以查看一下系统变量
>
> ```sql
> show variables like 'slow_query_log';
> ```
>
> 如果要开启慢查询日志，需要在MySQL的配置文件(/etc/my.cnf)中配置如下信息:
>
> ```shell
> # 开启MySQL慢查询日志开关
> slow_query_log=1
> # 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日记
> long_query_time=2
> # 记录执行较慢的管理语句
> log_slow_admin_statements=1
> # 记录执行较慢的未使用索引的语句
> log_queries_not_using_indexes=1
> ```
>
> 默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询语句。可以使用`log_slow_admin_statement`和`log_queries_not_using_indexes`
>
> 配置完毕之后吗，重启MySQL服务，查看慢日志文件中记录的信息`/var/lib/mysql/localhost-slow.log`

### profile详情

> `show profiles`能够在做SQL优化时帮助我们了解时间都消耗到哪里去了
>
> * 查看当前MySQL是否支持profile操作
>
>   ```sql
>   select @@have_profiling;
>   ```
>
> * 查看当前profile状态，0是关闭，1是开启
>
>   ```sql
>   select @@profiling;
>   ```
>
> * 开启profile
>
>   ```sql
>   set [session|global] profiling=1;
>   ```
>
> * 查看每一条SQL的耗时基本情况
>
>   ```sql
>   show profiles;
>   ```
>
> * 查看指定query_id的SQL语句各个阶段的耗时情况
>
>   ```sql
>   show profile for query query_id;
>   ```
>
> * 查看指定query_id的SQL语句CPU的使用情况
>
>   ```sql
>   show profile cpu for query query_id;
>   ```
>

### ※ explain

> explain或者desc命令获取MySQL如何执行select语句的信息，包括在select语句执行过程中表如何连接和连接的顺序
>
> **语法:**
>
> ```sql
> -- 直接在select语句之前加上关键字 explain/desc
> explain select 字段列表 from 表名 where 条件;
> ```
>
> **explain执行计划中各个字段的含义：**
>
> |       字段       |                             含义                             |
> | :--------------: | :----------------------------------------------------------: |
> |        id        | select查询的序列号，表示查询中执行select子句或者是操作表的顺序(**id相同，执行顺序从上到下；id不同，值越大，越先执行**) |
> |   select_type    | 表示select的类型，常见的取值有simple(简单表，即不使用表连接或者子查询)、primary(主查询，即外层的查询)、union(union中的第二个或者后面的查询语句)、subquery(select/where之后包含了子查询)等 |
> |     **type**     | **表示连接类型，性能由好到差的连接类型为Null、system、const、eq_ref，ref，range，index，all** |
> | **possible_key** |         **显示可能应用在查询表上的索引，一个或多个**         |
> |     **key**      |        **实际使用的索引，如果为Null，则没有使用索引**        |
> |   **key_len**    | **表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好** |
> |       rows       | MySQL认为必须要执行查询的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的 |
> |     filtered     | 表示返回结果的行数占需读取行数的百分比，filtered的值越大越好 |

## 索引使用

### 最左前缀法则

> 如果``索引了多列(联合索引)``，要遵守``最左前缀法则``。**最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中列。如果跳过某一列，索引将会部分失效(后面的字段索引失效)**
>
> `注意`：**`最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(既是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。`**

### 范围查询

> 联合索引中，**出现范围查询(>，<)，范围查询右侧的索引列失效**。
>
> 当范围查询使用>=或<=时，所有字段都是走索引的
>
> `注意`：**在业务允许的情况下，尽可能的使用类似于``>=``或``<=``这类的范围查询，而避免使用>或<**

### 索引失效情况

1. 索引列运算

   > **`不要在索引列上进行运算操作或函数运算操作，索引将会失效`**

2. 字符串不加引号

   > **`字符串类型字段使用时，不加引号，索引将会失效`**

3. 模糊查询

   > **`在like模糊查询中，在关键字后面加%，索引可以生效；而如果在关键字前面加了%，索引将会失效`**

4. or连接条件

   > **`当or连接的条件，左右两则字段都有索引时，索引才会生效；其中有一个字段没有索引，索引将会失效`**

5. 数据分布影响

   > **`MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。因为索引是用来索引少量数据的，如果通过索引查询返回大批量数据，则还不如走全表扫描来的快，此时索引就会失效`**

### SQL提示

> **SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。**

1. use index：建议MySQL使用哪一个索引完成此次查询(仅仅是建议，MySQL内部还会再次进行评估)

   ```sql
   explain select 字段 from 表名 use index(索引名称) where 条件;
   ```

2. ignore index：忽略指定的索引

   ```sql
   explain select 字段 from 表名 ignore index(索引名称) where 条件;
   ```

3. force index：强制使用指定的索引

   ```sql
   explain select 字段 from 表名 force index(索引名称) where 条件;
   ```

### 覆盖索引

> **`覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到`**。
>
> 尽量使用覆盖索引，减少`select * `；如果查询一直使用``select *``查询返回所有字段值，很容易就会造成回表查询(**除非是根据主键查询，此时只会扫描聚集索引**)

|          Extra           |                             含义                             |
| :----------------------: | :----------------------------------------------------------: |
| Using where；Using Index | 查找使用了索引，需要的数据都在索引列中能找到，所以不需要回表查询数据 |
|  Using Index condition   |             查找使用了索引，但是需要回表查询数据             |

### 前缀索引

> **当字段类型为字符串(varchar，text，longtext等)时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。**

1. 语法

   ```sql
   create index 索引名称 on 表名(字段名(n))
   ```

   > **`注意`**：**n代表的是提取前缀几个字符**

2. 前缀长度

   > 前缀长度可以根据索引的选择性来决定，而**`选择性是指不重复的索引值(基数)和数据表的记录总数的比值`**，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的
   >
   > eg:
   >
   > ```sql
   > select count(distinct substring(字段名,x,x))/count(*) from 表名;
   > ```

## 索引设计原则

> 1. `针对于数据量较大，且查询比较频繁的表建立索引`
> 2. `针对常作为查询条件(where)、排序(order by)、分组(group by)操作的字段建立索引`
> 3. `尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高`
> 4. `如果是字符串类型的字段，字段的长度较长，可以针对字段的特点，建立前缀索引`
> 5. `尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率`
> 6. `要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率`
> 7. `如果索引列不能存储Null值，请在创建表时使用Not Null约束它，当优化器知道每列是否包含Null值时，它可以更好地确定哪个索引最有效地用于查询`

# SQL优化

## 插入数据

### Insert

1. 批量插入数据

   ```sql
   Insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
   ```

2. 手动控制事务

   ```sql
   start transaction;
   insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
   insert into tb_test values(4,'Tom'),(5,'Cat'),(6,'Jerry');
   insert into tb_test values(7,'Tom'),(8,'Cat'),(9,'Jerry');
   commit;
   ```

3. 主键顺序插入，性能要高于乱序插入

   ```sql
   主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3
   主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89
   ```

### 大批量插入数据

> 如果一次性需要插入大批量数据，使用Insert语句插入性能比较低，此时可以使用MySQL数据库提供的**load指令**进行插入

```sql
-- 客户端连接服务端时，加上参数 --local-infile
mysql --local-infile -u root -p

-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
set global local_infile=1;

-- 执行load指令将准备好的数据，加载到表结构中
load data local infile 'sql文件存放位置' into table 表名 fileds terminated by ',' lines terminated by '\n';
```

## 主键优化

### 数据组织方式

> 在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为**索引组织表** (index organized table **IOT**)。
>
> ![](.\img\189.jpg)
>
> **行数据，都是存储在聚集索引的叶子节点上的。在InnoDB引擎中，数据行是记录在逻辑结构page页中的，而每一页的大小是固定的，默认16K。那也就意味着，一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储到下一个页中，页与页之间会通过指针连接**。

### 页分裂

> 页可以为空，也可以填充一半，也可以填充满，每个页包含了2-N行数据(如果一行数据过大，会溢出)，根据主键排列
>
> 1. 主键顺序插入效果
>
>    * 从磁盘中申请页，主键顺序插入
>    * 第一页没有满，继续往第一页插入
>    * 当第一页写满之后，再写第二个页，页与页之间会通过指针连接
>
> 2. 主键乱序插入效果
>
>    * 当1#，2#页都写满了，存放了如图所示的数据
>
>      ![](.\img\193.jpg)
>
>    * 此时再插入id为50的记录，按照顺序，应该存储在47之后，但47所在的1#页，已经写满了，存储不了50对应的数据了。那么此时会开辟一个新的页3#。
>
>      ![](.\img\194.jpg)
>
>    * 但是并不会直接将50存储在3#页，而是会将**1#页后一半的数据，移动到3#页，然后50在3#页插入**
>
>      ![](.\img\195.jpg)
>
>    * 那么此时，这三个页之间的数据顺序是有问题的，所以，此时，需要重新设置链表指针。**1#的下一页应该是3#，3#的下一页是2#**。
>
>      ![](.\img\196.jpg)

### 页合并

> * 当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记(flaged)为删除并且它的空间变得允许被其他记录声明使用
>
>   ![](.\img\198.jpg)
>
> * **当页中删除的记录达到merge_threshold(默认为页的50%)**，InnoDB会开始寻找最靠近的页(前或后)看看是否可以将两个页合并以优化空间使用。
>
>   ![](.\img\199.jpg)

> **`注意`**：**merge_threshold合并页的阈值，可以自己设置，在创建表或者创建索引时指定**

### 总结

> 1. **`满足业务需求的情况下，尽量降低主键的长度`**
> 2. **`插入数据时，尽量选择顺序插入，选择使用auto_increment自增主键`**
> 3. **`尽量不要使用UUID做主键或者是其他自然主键，如身份证号`**
> 4. **`业务操作时，避免对主键的修改`**

## order by优化

> * **`Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区Sort Buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序`**
> * **`Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为Using Index，不需要额外排序，操作效率高`**
>
> > **对于以上的两种排序方式，Using Index的性能高，而Using FileSort的性能低，我们在优化排序操作时，尽量要优化为Using Index。**
>
> > **Extra中出现了Backward index scan，这个代表反向扫描索引，因为在MySQL中我们创建的索引，默认索引的叶子节点是从小到大排序的，而此时我们查询排序时，是从大到小，所以，在扫描时，就是范向扫描，就会出现Backward index scan。在MySQL8版本中，支持降序索引，我们也可以创建降序索引。**
>
> > **`排序时，也要满足最左前缀法则，否则也会出现filesort。`**

### 总结

> 1. **`根据排序字段建立合适的索引，多字段排序时，也要遵循最左前缀法则`**
>
> 2. **`尽量使用覆盖索引`**
>
> 3. **`多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则(ASC/DESC)`**
>
>    ```sql
>    create index idx_xxxx on 表名(字段1 ASC,字段2 DESC);
>    ```
>
> 4. **`如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)`**

## group by优化

> 1. **`在分组操作时，可以通过索引来提高效率。`**
> 2. **`分组操作时，索引的使用也是满足最左前缀法则的。`**

## limit优化

> 在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。
>
> **优化思路：一般分页查询时，通过创建`覆盖索引`能够比较好地提高性能，可以通过`覆盖索引加子查询`形式进行优化**
>
> eg:
>
> ```sql
> explain select * from tb_sku t,(select id from tb_sku order by id limit 2000000,10) a where t.id=a.id;
> ```

## count优化

> * MyISAM引擎把一个表的总函数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高；但是如果是带条件的count，MyISAM也慢
> * InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数
>
> **优化思路：`自己计数(可以借助于Redis这样地数据库进行`，但是如果是带条件的count又比较麻烦了)**
>
> **按照效率排序**：count(字段)<count(主键id)<count(1)≈count( * )，所以尽量使用count( * )

## update优化

> eg:
>
> ```sql
> update course set name='JavaEE' where id =1;
> ```
>
> > 当我们在执行更新的SQL语句时，会锁定id为1这一行的数据，然后事务提交之后，行锁释放
>
> ```sql
> update course set name='Spring' where name='MySQL';
> ```
>
> > 当我们开启多个事务，在执行上述的SQL时，我们发现行锁升级为了表锁。

### 总结

> **`更新条件最好是索引值列，InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁`**

# 视图

## 介绍

> **视图(View)是一种虚拟存在的表，是一个逻辑表，本身并不包含数据，行和列数据来自定义视图的查询中使用的表(基表)，并且是在使用视图时动态生成的。**
>
> **`视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要工作就落在创建这条SQL查询语句上`**

## 语法

1. 创建

   ```sql
   create [or replace] view 视图名称 as 查询语句 [with [cascaded | local] check option]
   ```

   > 可选项：
   >
   > * or replace：或替换视图
   > * 视图名称：建议用列名列表组合
   > * witch [cascaded | local] check option：检查选项
   >   * cascaded：级联
   >   * local：本地

2. 查询

   ```sql
   -- 查看创建试图语句
   show create view 视图名称;
   -- 查看视图数据
   select * from 视图名称 [where 条件...];
   ```

3. 修改

   ```sql
   -- 方式一
   create or replace view 视图名称 as 查询语句 [with [cascaded | local] check option]
   -- 方式二
   alter view 视图名称 as 查询语句 [with [cascaded | local] check option]
   ```

4. 删除

   ```sql
   drop view [if exists] 视图名称[,视图名称] ....;
   ```

## 检查选项

> 当使用`with check option`子句创建视图时，MySQL会通过视图检查正在更改的每个行，列如插入、更新、删除，以使其符合视图的定义。MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，MySQL提供了两个选项：`cascaded`和`local`，默认值为**`cascaded`**
>
> * cascaded：级联
>
>   * 例如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为cascaded，但是v1视图创建时未指定检查选项。**则在执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1**
>
>     ![](.\img\200.jpg)
>
> * local：本地
>
>   * 例如：v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为local，但是v1视图创建时未指定检查选项。**则在执行检查时，先检查v2，再往上继续检查是否有检查选项，有检查选项就执行，没有就不执行**
>
>     ![](.\img\201.jpg)
>
> > **`总结：cascaded是强制向上级联，local是有检查选项才级联`**

## 视图的更新

> **要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：**
>
> * 聚合函数或窗口函数(sum()，min()，max()，count()等)
> * distinct
> * group by
> * having
> * union或者union all

## 视图的作用

> 1. 简单
>    * 视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件
>
> 2. 安全
>    * 数据库可以授权，但不能授权到数据库特定的行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据
> 3. 数据独立
>    * 视图可帮助用户屏蔽真实表结构变化带来的影响

# 存储过程

## 介绍

> 存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。存储过程思想上很简单，就是**数据库SQL语言层面的代码封装与重用**
>
> 特点：
>
> * 封装、复用
>   * 可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可
> * 可以接收参数，也可以返回数据
>   * 在存储过程中，可以传递参数，也可以接收返回值
> * 减少网络交互，效率提升
>   * 如果涉及到多条SQL,每执行一次都是一次网络传输。而如果封装在存储过程中，我们只需要网络交互一次可能就可以了

## 基本语法

1. 创建

   ```sql
   create procedure 存储过程名称([参数列表])
   begin
   	-- SQL语句
   end;
   ```

2. 调用

   ```sql
   call 名称 ([参数]);
   ```

3. 查看

   ```sql
   -- 查询指定数据库的存储过程及状态信息
   select * from information_schema.ROUTINES where ROUTINE_SCHEMA='数据库名称';;
   -- 查询某个存储过程的定义
   show create procedure 存储过程名称;
   ```

4. 删除

   ```sql
   drop procedure [if exists] 存储过程名称;
   ```

> **`注意`**：**在命令行中，执行创建存储过程的SQL时，需要通过关键字delimiter指定SQL语句的结束符**

## 变量

> 在MySQL中变量分为三种类型：系统变量、用户定义变量、局部变量。

### 系统变量

> 系统变量是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量(global)、会话变量(session)。

1. 查看系统变量

   ```sql
   -- 查看系统所有变量
   show [session|global] variables;
   -- 可以通过like模糊匹配方式查找变量
   show [session|global] variables like 'xxxx';
   -- 查看指定变量的值
   select @@[session|global] 系统变量名;
   ```

2. 设置系统变量

   ```sql
   set [session|global] 系统变量名=值;
   set @@[session|global] 系统变量名=值
   ```

> **`注意`**：**如果没有指定session或global，默认是session(会话变量)**
>
> > MySQL服务重新启动之后，所设置的全局参数会失效，想要不失效，可以在/etc/my.cnf中配置

### 用户定义变量

> 用户定义变量是用户根据需要自己定义的变量，**用户变量不用提前声明，在用的时候直接用``@变量名``使用就可以**。**其作用域为当前连接**。

1. 赋值

   ```sql
   -- 方式一
   set @变量名=值[,@变量名=值]...;
   set @变量名:=值[,@变量名:=值]...;
   
   -- 方式二
   select @变量名:=值[,@变量名:=值]...;
   select 字段名 into @变量名 from 表名;
   ```

2. 使用

   ```sql
   select @变量名;
   ```

> **`注意`**：**用户定义的变量无需对其进行声明或初始化，只不过获取到的值为Null**

### 局部变量

> 局部变量是根据需要定义的在局部生效的变量，**访问之前，需要``declare``声明。可用作存储过程内的局部变量和输入参数，`局部变量的范围是在其内声明的`begin...end`块`**。

1. 声明

   ```sql
   declare 变量名 变量类型 [default ...];
   ```

   > 变量类型就是数据库字段类型：int、bigint、char、varchar、date、time等

2. 赋值

   ```sql
   set 变量名=值;
   set 变量名:=值;
   select 字段名 into 变量名 from 表名 ...;
   ```

3. eg

   ```sql
   create procedure p2()
   begin
   	declare stu_count int default 0;
   	select count(*) into stu_count from student;
   	select stu_count;
   end;
   
   call p2();
   ```

## if

```sql
if 条件1 then
	...
elseif 条件2 then
	...
else
	...
end if;
```

> **在if条件判断的结构中，elseif结构可以有多个，也可以没有。else结构可以有，也可以没有。**
>
> eg：
>
> ```sql
> create procedure p3()
> begin
> 	declare score int default 58;
> 	declare result varchar(10);
> 	if score>=85 then
> 		set result:='优秀';
> 	elseif score>=60 then
> 		set result:='及格';
>     	else
>     		set result:='不及格';
>     	end if;
>     	select result;
> end;
> 
> call p3();
> ```

## 参数

1. 介绍

   > 参数的类型，主要分为以下三种：in、out、inout
   >
   > | 类型  |                     含义                     | 备注 |
   > | :---: | :------------------------------------------: | :--: |
   > |  in   |   该类参数作为输入，也就是需要调用时传入值   | 默认 |
   > |  out  | 该类参数作为输出，也就是该参数可以作为返回值 |      |
   > | inout |    既可以作为输入参数，也可以作为输出参数    |      |

2. 用法

   ```sql
   create procedure 存储过程名称([in/out/inout 参数名 参数类型])
   begin
   	-- SQL语句
   end;
   ```

3. 示例

   > ```sql
   > create procedure p4(in score int,out result varchar(10))
   > begin
   > 	if score >= 85 then
   > 		set result := '优秀';
   > 	elseif score >= 60 then
   > 		set result := '及格';
   > 	else
   > 		set result := '不及格';
   > 	end if;
   > end;
   > 
   > -- 定义用户变量@result来接收返回的数据，用户变量可以不用声明
   > call p4(18,@result);
   > 
   > select @result;
   > ```

## case

1. 语法

   ```sql
   case case_value
   	when when_value1 then result_value1
   	[when when_value2 then result_value2] ...
   	[else result]
   end case;
   -- 含义：当case_value的值为when_value1时，执行result_value1，否则就执行result结果
   ```

   ```sql
   case
   	when when_value1 then result_value1
   	[when when_value2 then result_value2] ...
   	[else result]
   end case;
   -- 含义：当条件when_value1成立时，执行result_value1，否则就执行result；
   ```

2. 示例

   > ```sql
   > create procedure p6(in month int)
   > begin
   > 	declare result varchar(10);
   > 	case 
   > 		when month >=1 and month <=3 then
   > 			set result:='第一季度';
   > 		when month >=4 and month <=6 then
   > 			set result:='第二季度';
   > 		when month >=7 and month <=9 then
   > 			set result:='第三季度';
   > 		when month >=10 and month <=12 then
   > 			set result:='第四季度';
   > 		else
   > 			set result:='非法参数';
   > 	end case;
   > 	
   > 	select concat('您输入的月份为：',month,'，所属的季度为：',result);
   > end;
   > 
   > call p6(10);
   > ```

## while

1. 语法

   ```sql
   while 条件 do
   	SQL逻辑...
   end while;
   -- 先判断条件，如果条件为true，则执行下面的SQL逻辑，否则，不执行
   ```

2. 示例

   ```sql
   create procedure p7(in n int)
   begin
   	declare total int default 0;
   	while n>0 do
   		set total:=total+n;
   		set n:=n-1;
   	end while;
   	
   	select total;
   end;
   
   call p7(3);
   ```

## repeat

1. 语法

   ```sql
   repeat
   	SQL逻辑...
   until 条件
   end repeat;
   -- 先执行一次逻辑，然后判定until条件是否满足，如果满足，则退出，如果不满足，则继续下一次循环
   ```

2. 示例

   ```sql
   create procedure p8(in n int)
   begin
   	declare total int default 0;
   	repeat
   		set total:=total+n;
   		set n:=n-1;
   	until n<=0
   	end repeat;
   	select total;
   end;
   
   call p8(3);
   ```

## loop

1. 语法

   > loop实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。
   >
   > loop可以配合以下两个语句使用：
   >
   > * leave：配合循环使用，退出循环。
   > * iterate：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。

   ```sql
   [begin_label:]loop
   	SQL逻辑...
   end loop [end_label];
   ```

   > leave label：退出指定标记的循环体
   >
   > iterate label：直接进入下一次循环
   >
   > > 上述语法中出现的begin_label，end_label，label指的都是我们所自定义的标记

2. 示例

   ```sql
   -- 计算从1累加到n的值，n为传入的参数值
   create procedure p9(in n int)
   begin
   	declare total int default 0;
   	
   	sum:loop
   		if n<=0 then
   			leave sum;
   		end if;
   		
   		set total:=total+n;
   		set n:=n-1;
   	end loop sum;
   	
   	select total;
   end;
   
   call p9(100);
   ```

   ```sql
   -- 计算从1到n之间的偶数累加的值，n为传入的参数值
   create procedure p10(in n int)
   begin
   	declare total int default 0;
   	
   	sum:loop
   		if n<=0 then
   			leave sum;
   		end if;
   		
   		if n%2=1 then
   			set n:=n-1;
   			iterate sum;
   		end if;
   		
   		set total:=total+n;
   		set n:=n-1;
   	end loop sum;
   	select total;
   end;
   
   call p10(100);
   ```

## 游标

1. 介绍

   > 游标(cursor)是**用来`存储查询结果集`的数据类型**，在存储过程和函数中可以使用游标对结果集进行循环的处理

2. 语法

   * 声明游标

     ```sql
     declare 游标名称 cursor for 查询语句;
     ```

   * 打开游标

     ```sql
     open 游标名称;
     ```

   * 获取游标记录

     ```sql
     fetch 游标名称 into 变量 [, 变量];
     ```

   * 关闭游标

     ```sql
     close 游标名称;
     ```

3. 示例

   ```sql
   create procedure p11(in uage int)
   begin
   	declare uname varchar(100);
   	declare upro varchar(100);
   	declare u_cursor cursor for select name,profession from tb_user where age<=uage;
   	
   	drop table if exists tb_user_pro;
   	create table tb_user_pro(
   		id int primary key auto_increment comment '主键ID',
   		name varchar(100) comment '姓名',
   		profession varchar(100) comment '职业'
   	)comment '用户职业表-游标';
   	
   	open u_cursor;
   	
   	while true do
   		fetch u_cursor into uname,upro;
   		insert into tb_user_pro values(null,uname,upro);
   	end while;
   	
   	close u_cursor;
   end;
   
   call p11(30);
   ```

## 条件处理程序

1. 介绍

   > 条件处理程序(Handler)可以用来定义在**流程控制结构执行过程中遇到问题时相应的处理步骤**

2. 语法

   ```sql
   declare {handler_action} handler for {condition_value [,condition_value]} SQL逻辑;
   ```

   * `handler_action`的取值
     * **continue**：继续执行当前程序
     * **exit**：终止执行当前程序
   * `condition_value`取值
     * **sqlstate ‘状态码’**：状态码，如02000	
     * **sqlwarning**：所有以01开头的sqlstate代码简写
     * **not found**：所有以02开头的sqlstate代码的简写
     * **sqlexception**：所有没有被sqlwarning或not found捕获的sqlstate代码的简写

   > 更多状态码：https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html

3. 示例

   ```sql
   create procedure p11(in uage int)
   begin
   	declare uname varchar(100);
   	declare upro varchar(100);
   	declare u_cursor cursor for select name,profession from tb_user where age<=uage;
   	
   	-- 声明条件处理程序：当SQL语句执行抛出的状态码为02000时，将关闭游标u_cursor，并退出
   	declare exit handler for sqlstate '02000' close u_cursor;
   	
   	drop table if exists tb_user_pro;
   	create table tb_user_pro(
   		id int primary key auto_increment comment '主键ID',
   		name varchar(100) comment '姓名',
   		profession varchar(100) comment '职业'
   	)comment '用户职业表-游标';
   	
   	open u_cursor;
   	
   	while true do
   		fetch u_cursor into uname,upro;
   		insert into tb_user_pro values(null,uname,upro);
   	end while;
   	
   	close u_cursor;
   end;
   
   call p11(30);
   ```

# 存储函数

1. 介绍

   > **存储函数是有返回值的存储过程，存储函数的参数只能是`IN`类型的**

2. 语法

   ```sql
   create function 存储函数名称([参数列表])
   returns type [characteristic ...]
   begin
   	--SQL逻辑
   	return ...;
   end;
   ```

   * characteristic说明：
     * **`deterministic`**：相同的输入参数总是产生相同的结果
     * **`no sql`**：不包含sql语句
     * **`reads sql data`**：包含读取数据的语句，但不包含写入数据的语句

3. 示例

   ```sql
   create function fun1(n int)
   returns int deterministic
   begin
   	declare total int default 0;
   	while n>0 do
   		set total:=total+n;
   		set n:=n-1;
   	end while;
   	
   	return total;
   end;
   
   select fun1(100);
   ```

# 触发器

## 介绍

> **触发器是与表有关的数据库对象，指在insert/update/delete之前(before)或之后(after)，触发并执行触发器中定义的SQL语句集合**。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日记记录，数据校验等操作。
>
> **使用别名old和new来引用触发器中发生变化的记录内容**，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。
>
> |   触发器类型   |                       new和old                       |
> | :------------: | :--------------------------------------------------: |
> | insert型触发器 |            new表示将要或者已经新增的数据             |
> | update型触发器 | old表示修改之前的数据，new表示将要或已经修改后的数据 |
> | delete型触发器 |            old表示将要或者已经删除的数据             |

## 语法

1. 创建

   ```sql
   create trigger 触发器名称
   before/after insert/update/delete on 表名 for each row --行级触发器
   begin
   	SQL语句;
   end;
   ```

2. 查看

   ```sql
   show triggers;
   ```

3. 删除

   ```sql
   drop trigger [数据库名称.]触发器名称;
   -- 如果没有指定数据库名，默认为当前数据库
   ```

## 示例

1. 创建日志记录表

   ```sql
   create table user_logs(
   	id int(11) not null primary key auto_increment,
   	operation varchar(20) not null comment '操作类型，insert/update/delete',
   	operation_time datetime not null comment '操作时间',
   	operation_id int(11) not null comment '操作的ID',
   	operation_params varchar(500) comment '操作参数'
   )engine=innodb default charset=utf8;
   ```
   
2. 插入数据触发器

   ```sql
   create trigger tb_user_insert_trigger
   after insert on tb_user for each row
   begin
   	insert into user_logs(id,operation,operation_time,operation_id,operation_params) values (null,'insert',now(),new.id,concat('插入的数据内容为:id=',new.id,',name=',new.name,',phone=',new.phone,',email=',new.email,',profession=',new.profession));
   end;
   
   -- 测试
   insert into tb_user(id, name, phone, email, profession, age, gender, status,createtime) VALUES (26,'三皇子','18809091212','erhuangzi@163.com','软件工程',23,'1','1',now());
   ```

3. 修改数据触发器

   ```sql
   create trigger tb_user_update_trigger
   after update on tb_user for each row
   begin
   	insert into user_logs(id,operation,operation_time,operation_id,operation_params) values (null,'update',now(),new.id,concat('更新之前的数据:id=',old.id,',name=',old.name,',phone=',old.phone,',email=',old.email,',profession=',old.profession,'||更新之后的数据:id=',new.id,',name=',new.name,',phone=',new.phone,',emial=',new.email,',profession=',new.profession));
   end;
   
   -- 测试
   update tb_user set profession = '会计'where id = 23;
   update tb_user set profession = '会计'where id <= 5;
   ```

4. 删除数据触发器

   ```sql
   create trigger tb_user_delete_trigger
   after delete on tb_user for each row
   begin
   	insert into user_logs(id,operation,operation_time,operation_id,operation_params) values (null,'delete',now(),old.id,concat('删除之前的数据:id=',old.id,',name=',old.name,',phone=',old.phone,',email=',old.email,',profession=',old.profession));
   end;
   
   --测试
   delete from tb_user where id=26;
   ```

# 锁

> **锁是计算机协调多个进程或线程并发访问某一资源的机制**。在数据库中，除传统的计算资源(CPU、RAM、I/O)的争用以外，数据也是一种供许多用户共享的资源。如何**保证数据并发访问的一致性、有效项**是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。
>
> MySQL中的锁，按照锁的粒度分，分为以下三类
>
> * 全局锁：锁定数据库中的所有表
> * 表级锁：每次操作锁住整张表
> * 行级锁：每次操作锁住对应的行数据

## 全局锁

> **全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，以及更新操作的事务提交都将被阻塞**
>
> 其典型的使用场景是做**全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性**。

### 语法

1. 加全局锁

   ```sql
   flush tables with read lock;
   ```

2. 数据备份

   ```sql
   mysqldump -u root -p 密码 数据库名>备份数据名.sql
   ```

3. 释放锁

   ```sql
   unlock tables;
   ```

### 特点

> 数据库中加全局锁，是一个比较重的操作，存在以下问题：
>
> * 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆
> * 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志(binlog)，会导致主从延迟
>
> > 在InnoDB引擎中，我们可以在备份时加上参数`--single-transaction`参数来完成不加锁的一致性数据备份
> >
> > ```sql
> > mysqldump --single-transaction -u root -p 密码 数据库名>备份数据库名.sql
> > ```

## 表级锁

> 表级锁，**每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低**。应用在MyISAM、InnoDB、BDB等存储引擎中
>
> 对于表级锁，主要分为以下三类：
>
> * 表锁
> * 元数据锁(meta data lock，MDL)
> * 意向锁

### 表锁

1. 介绍

   > 对于表锁，分为两类：
   >
   > * 表共享读锁(read lock)：**针对同一份数据，多个读操作可以同时进行而不会互相影响。**
   >
   >   ![](.\img\202.jpg)
   >
   > * 表独占写锁(write lock)：**当前写操作没有完成前，它会阻断其他写锁和读锁。**
   >
   >   ![](.\img\203.jpg)

2. 语法

   * 加锁

     ```sql
     lock tables 表名 {read/write} [,表名 {read/write}]
     ```

   * 释放锁

     ```sql
     unlock tables / 客户端断开连接
     ```

> **`总结`**：**读锁不会阻塞其他客户端的读，但是会阻塞写；写锁即会阻塞其他客户端的读，也会阻塞其他客户端的写**

### 元数据锁

> **MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上**。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。**`为了避免DML与DDL冲突，保证读写的正确性`**
>
> **`这里的元数据，可以简单理解为就是一张表的表结构。也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的`**
>
> 在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变更操作的时候，加MDL写锁(排他)
>
> 常见的SQL操作时，所添加的元数据锁：
>
> |                   对应SQL                   |                锁类型                 |                       说明                       |
> | :-----------------------------------------: | :-----------------------------------: | :----------------------------------------------: |
> |         lock tables 表名 read/write         | shared_read_only/shared_no_read_write |                                                  |
> |    select、select... lock in share mode     |              shared_read              | 与shared_read、shared_write兼容，于exclusive互斥 |
> | insert、update、delete、select...for update |             shared_write              | 与shared_read、shared_write兼容，于exclusive互斥 |
> |               alter table ...               |               exclusive               |              **与其他的MDL都互斥**               |

> **查看数据库中的元数据锁的情况**
>
> ```sql
> select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks;
> ```

### 意向锁

1. 介绍

   > **为了避免DML在执行时，加的`行锁与表锁的冲突`，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。**
   >
   > 假如没有意向锁，客户端一对表加了行锁后，当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就会从第一行数据，检查到最后一行数据，效率较低。
   >
   > ![](.\img\204.jpg)
   >
   > 有了意向锁之后，客户端一在**执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁**；而其他客户端，在对这种表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐步判断行锁情况。
   >
   > ![](.\img\205.jpg)

2. 分类
   * 意向共享锁(IS)：由语句`select ... lock in share mode`添加。与**表锁共享读锁(read)兼容，与表锁排它写锁(write)互斥**
   * 意向排他锁(IX)：由`insert、update、delete、select ... for update`添加。与**表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥**

> **`一旦事务提交了，意向锁、意向排他锁，都会自动释放`**

> **查看意向锁及行锁的加锁情况**
>
> ```sql
> select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;
> ```

## 行级锁

> 行级锁，**每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高**。应用在InnoDB存储引擎中。
>
> InnoDB的数据是基于索引组织的，**`行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁`**
>
> 对于行级锁，主要分为以下三类：
>
> * 行锁(Record Lock)：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC(Read Commited)、RR(Repeatable Read)隔离级别下都支持
>
>   ![](.\img\206.jpg)
>
> * 间隙锁(Gap Lock)：锁定索引记录间隙(不含该记录)，确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR(Repeatable Read)隔离级别下都支持
>
>   ![](.\img\207.jpg)
>
> * **`临键锁(Next-Key Lock)：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙`**。在RR(Repeatable Read)隔离级别下支持
>
>   ![](.\img\208.jpg)

### 行锁

1. InnoDB实现了以下两种类型的行锁：

   * 共享锁(S)：**允许任何获取共享锁的事务去读一行，阻止其他事务获得相同数据集的排它锁**。
   * 排他锁(X)：**允许任何获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁**

   ![](.\img\209.jpg)

2. 常见的SQL语句，在执行时，所加的行锁如下：

   |              SQL              |  行锁类型  |                   说明                   |
   | :---------------------------: | :--------: | :--------------------------------------: |
   |          insert ...           |   排他锁   |                 自动加锁                 |
   |          update ...           |   排他锁   |                 自动加锁                 |
   |          delete ...           |   排他锁   |                 自动加锁                 |
   |          select ...           | 不加任何锁 |                                          |
   | select ... lock in share mode |   共享锁   | 需要手动在select之后加lock in share mode |
   |     select ... for update     |   排他锁   |     需要手动在select之后加for update     |

> **默认情况下，InnoDB在Repeatable Read事务隔离级别运行，InnoDB使用Next-Key(临键锁)锁进行搜索和索引扫描，以防止幻读**。
>
> * 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。
> * InnoDB的行锁是针对于**索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会行锁升级为表锁**。

### 间隙锁&临键锁

> * 索引上的等值查询(唯一索引)，给不存在的记录加锁时，优化为间隙锁
>
> * 索引上的等值查询(非唯一普通索引，也就是二级索引)，向右遍历时最后一个值不满足查询需求时，Next-Key Lock退化为间隙锁
>
>   * InnoDB的B+树索引叶子节点是有序的双向链表。假如我们要根据二级索引查询值为18的数据，并加上共享锁，我们不只是锁住18这一行，因为是非唯一索引，这个结构中可能有多个18的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值(当前案例中也就是29)，此时会对18加临键锁，并对29之间的间隙加锁
>
>     ![](.\img\215.jpg)
>
> * 索引上的范围查询(唯一索引)会访问到不满足条件的第一个值为止
>
> > **`注意`**：**间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁**

# InnoDB引擎

## 架构

### 概述

> MySQL5.5版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。
>
> * InnoDB架构图，左侧为内存结构，右侧为磁盘结构
>
>   ![](.\img\210.jpg)

### 内存结构

* Buffer Pool

  > **InnoDB存储引擎基于磁盘文件存储**，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I/O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I/O。
  >
  > 在InnoDB的缓冲池不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等。
  >
  > **缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据(若缓冲池没有数据，则从磁盘加载并缓存)，然后再以一定频率刷新到磁盘，从而减少磁盘I/O，加快处理速度**
  >
  > 缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：
  >
  > * free page：空闲page，未被使用
  > * clean page：被使用page，数据没有被修改过
  > * dirty page：脏页，被使用page，数据被修改过，数据与磁盘的数据产生了不一致

* Chnage Buffer

  > **更改缓冲区(针对于非唯一二级索引页)，在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区(Change Buffer)中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中**

* Adaptive Hash Index

  > 自适应Hash索引，用于优化对Buffer Pool数据的查询。InnoDB引擎虽然没有直接支持Hash索引，但是给用户提供了一个功能就是这个自适应Hash索引。Hash索引在进行等值匹配时，一般性能是要高于B+树的，因为Hash索引一般只需要一次IO即可，而B+树可能需要几次匹配，所以Hash索引的效率要高，但是Hash索引又不适合做范围查询、模糊匹配等
  >
  > **InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下Hash索引可以提升速度，则建立Hash索引，称之为自适应Hash索引**
  >
  > **自适应哈希索引，无需人工干预，是系统根据情况自动完成**

* Log Buffer

  > 日志缓冲区，用来保存要写入到磁盘中的Log日志数据(redo log、undo log)，默认大小为16M，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘I/O
  >
  > 参数：
  >
  > * innodb_log_buffer_size：缓冲区大小
  > * innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：
  >   * 1：日志在每次事务提交时写入并刷新到磁盘，默认值。
  >   * 0：每秒将日志写入并刷新到磁盘一次
  >   * 2：日志在每次事务提交后写入，并每秒刷新到磁盘一次

### 磁盘结构

* System Tablespace

  > **系统表空间是更改缓冲区(Change Buffer)的存储区域**。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据
  >
  > 参数：`innodb_Data_file_path`

* File-Per-Table Tablespaces

  > 如果开启了`innodb_file_per_table`开关(该参数默认开启)，则每个表的文件表空间包含单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件中

* General Tablespaces

  > 通用表空间，需要通过`create tablespace`语法创建通用表空间，在创建表时，可以指定该表的表空间

* Undo Tablespaces

  > 撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间(初始大小16M)，用于存储`undo log`日志

* Temporary Tablespaces

  > InnoDB使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据

* Doublewrite Buffer Files

  > **双写缓冲区，InnoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓存区文件中，便于系统异常时恢复数据**
  >
  > * `#ib_16384_0.dblwr`
  > * `#ib_16384_1.dblwr`

* Redo Log

  > **重做日志(Redo Log)，是用来实现事务的持久性**。该日志文件由两部分组成：**重做日志缓冲区(redo log buffer)**以及**重做日志文件(redo log)**，前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复使用
  >
  > 以循环方式写入重做日志文件，涉及两个文件：
  >
  > * ib_logfile0
  > * ib_logfile1

### 后台线程

> **InnoDB的后台线程的主要作用是将内存中的数据刷新到磁盘中**，在InnoDB的后台线程中，分为四类：Master Thread、IO Thread、Purge Thread、Page Cleaner Thread
>
> ![](.\img\211.jpg)

* Master Thread

  > 核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中，保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收

* IO Thread

  > 在InnoDB存储引擎中大量使用了AIO来处理IO请求，这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调
  >
  > |       线程类型       | 默认个数 |             职责             |
  > | :------------------: | :------: | :--------------------------: |
  > |     Read Thread      |    4     |          负责读操作          |
  > |     Write Thread     |    4     |          负责写操作          |
  > |      Log Thread      |    1     |  负责将日志缓冲区刷新到磁盘  |
  > | Insert buffer thread |    1     | 负责将写缓冲区内容刷新到磁盘 |

* Purge Thread

  > 主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，Purge Thread就负责回收

* Page Cleaner Thread

  > 协助Master Thread刷新脏页到磁盘的线程，它可以减轻Master Thread的工作压力，减少阻塞

## 事务原理

> 实际上，研究事务的原理，就是研究MySQL的InnoDB引擎是如何保证事务的四大特性的。而对于四大特性，实际上分为两个部分。其中**原子性、一致性、持久化是由InnoDB中的两份日志来保证的，一份是`redo log`日志，一份是`undo log`日志。而隔离性是通过数据库的锁，加上MVCC来保证的。**
>
> ![](.\img\212.jpg)

### redo log

> **重做日志(redo log)，记录的是事务提交时数据页的物理修改，是用来实现事务的`持久性`**
>
> 该日志文件由两部分组成：重做日志缓冲(redo log buffer)以及重做日志文件(redo log file)；前者是在内存中，后者是在磁盘中。**当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘发生错误时，进行数据恢复使用**

> 在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池(Buffer Pool)，在缓冲池中缓存了很多的数据页。**当我们在一个事务中，执行多个增删改的操作时，InnoDB会先操作缓冲池的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池的数据修改，修改后的数据页我们称为脏页。而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致(`持久性的由来`)。而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程中出错了，而提示给用户事务提交成功，而数据却没有持久化下来，这就出现问题了，没有保证事务的持久性。**
>
> ![](.\img\213.jpg)
>
> > **`有了`redo log`之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在`redo log buffer`中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页数据到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性`**。而如果脏页成功刷新到磁盘或涉及到的数据已经落盘，此时redo log就没有作用了，就可以删除了，所以存在两个redo log文件是循环写的
>
> ![](.\img\214.jpg)
>
> **为什么每一次提交事务，要刷新redo log到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢？**
>
> **`因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。这种先写日志的方式，称之为WAL(Write-Ahead Logging)`**

### undo log

> **`回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚(保证事务的`原子性`)和MVCC(多版本并发控制)`**
>
> **undo log和redo log记录物理日志不一样，它是逻辑日志。`可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚`**。
>
> Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC
>
> Undo log存放：undo log采用段的方式进行管理和记录，存放在回滚段中，内部包含1024个undo log segment

## MVCC

### 基本概念

* 当前读

  > **读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁**。对于我们日常的操作，如：`select ... locak in share mode(共享锁)`，`select ... for update`、`update`、`insert`、`delete`(排他锁)都是一种当前读。

* 快照读

  > **简单的select(不加锁)就是快照读，快照读读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读**。
  >
  > * Read Commited：每次select，都生成一个快照读
  > * Repeatable Read：开启事务后第一个select语句才是快照读的地方，后面执行相同的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就保证了可重复读
  > * Serizalizable：快照读会退化为当前读

* MVCC

  > 全称Multi-Version Concurrency Control，多版本并发控制。**指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的`三个隐式字段、undo log日志、readView`**

### 隐藏字段

> 我们在查看表结构的时候，就可以显示的看到我们新建时创建的字段。实际上除了我们新建时创建的字段外，InnoDB还会自动地给我们添加三个隐藏字段
>
> |  隐藏字段   |                             含义                             |
> | :---------: | :----------------------------------------------------------: |
> |  DB_TRX_ID  | 最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID |
> | DB_ROLL_PTR | 回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本 |
> |  RB_ROW_ID  |     隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段     |
>
> 上述的前两个字段是肯定会添加的，是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，如果有主键，则不会添加该隐藏字段

### undo log

> 回滚日志(undo log)，在insert、update、delete的时候产生的便于数据回滚的日志
>
> 当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除
>
> 而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除

* 版本链

  ![](.\img\216.jpg)

  ![](.\img\217.jpg)

  > **不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录**。

### ReadView

> **ReadView(读视图)是`快照读`SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务(未提交的)ID**
>
> |      字段      |              含义              |
> | :------------: | :----------------------------: |
> |     m_ids      |      当前活跃的事务ID集合      |
> |   min_trx_id   |         最小活跃事务ID         |
> |   max_trx_id   | 预分配事务ID，当前最大事务ID+1 |
> | creator_trx_id |     ReadView创建者的事务ID     |
>
> 而在ReadView中就规定了版本链数据的访问规则：**`trx_id代表当前undo log版本链对应事务ID`**
>
> |              条件              |               是否可以访问                |                   说明                   |
> | :----------------------------: | :---------------------------------------: | :--------------------------------------: |
> |     trx_id==creator_trx_id     |              可以访问该版本               |    成立，说明数据是当前这个事务更改的    |
> |       trx_id<min_trx_id        |              可以访问该版本               |         成立，说明数据已经提交了         |
> |       trx_id>max_trx_id        |             不可以访问该版本              | 成立，说明该事务是在ReadView生成后才开启 |
> | min_trx_id<=trx_id<=max_trx_id | 如果trx_id不在m_ids中，是可以访问该版本的 |          成立，说明数据已经提交          |
>
> 不同的隔离级别，生成ReadView的时机不同：
>
> * Read Commited(RC)：在事务中每一次执行快照读时生成ReadView
> * Repeatable Read(RR)：仅在事务中第一次执行快照时生成ReadView，后续复用该ReadView

### 原理分析

* RC隔离级别

  > 在事务5中，查询了两次id为30的记录，由于隔离级别为RC，所以每一次进行快照读都会生成一个ReadView，那么两次生成的ReadView如下：
  >
  > ![](.\img\218.jpg)

* RR隔离级别

  > RR隔离级别下，仅在事务中第一次执行快照读时生成的ReadView，后续复用该ReadView。而RR是可重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的
  >
  > ![](.\img\219.jpg)

# 日志

## 错误日志

> 错误日志是MySQL中最重要的日志之一，它记录了当mysqld启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。
>
> 该日志是默认开启的，默认存放目录`/var/log/`，默认的日志文件名为`mysqld.log`
>
> 查看日志位置：`show variables like ‘%log_error%’`

## 二进制日志

### 介绍

> **二进制日志(binlog)记录了所有的DDL(数据库定义语言)语句和DML(数据操纵语言)语句，但不包括数据查询语句。**
>
> 作用：
>
> * 灾难时的数据恢复
> * MySQL的主从复制
>
> 查看信息：`show variables like ‘%log_bin%’`
>
> ![](.\img\220.jpg)
>
> 参数说明：
>
> * log_bin_basename：当前数据库服务器的binlog日志的基础名称(前缀)，具体的binlog文件名需要在该basename的基础上加上编号(编号从000001开始)
> * log_bin_index：binlog的索引文件，里面记录了当前服务器关联的binlog文件有哪些

### 格式

> MySQL服务器中提供了多种格式来记录二进制日志，具体格式及特点如下：
>
> | 日志格式  |                             含义                             |
> | :-------: | :----------------------------------------------------------: |
> | statement | **基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在日志文件中** |
> |    row    |     **基于行的日志记录，记录的是每一行的数据变更(默认)**     |
> |   mixed   | 混合了statement和row两种格式，默认采用statement，在某些特殊情况下会自动切换为row进行记录 |
>
> 查看格式：`show variables like ‘%binlog_format%’`
>
> 如果需要配置二进制日志的格式，只需要在`/etc/my.cnf`中配置binlog_format参数即可

### 查看

> 由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具`mysqlbinlog`来查看，具体语法
>
> ```sql
> mysqlbinlog [参数选项] 名称
> ```
>
> 参数选项：
>
> * -d：指定数据库名称，只列出指定的数据库相关操作
> * -o：忽略掉日志中的前n行命令
> * -v：将行事件(数据变更)重构为SQL语句
> * -vv：将行事件(数据变更)重构为SQL语句，并输出注释信息

### 删除

> 对于比较繁忙的业务系统，每天生成了binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间。可以通过以下几种方式清理日志：
>
> |                       指令                       |                             含义                             |
> | :----------------------------------------------: | :----------------------------------------------------------: |
> |                   reset master                   | 删除全部binlog日志，删除之后，日志编号，将从binlog.00001重新开始 |
> |         purge master logs to ‘binlog.*’          |                   删除*编号之前的所有日志                    |
> | purge master logs before ‘yyyy-mm-dd hh24:mi:ss’ |     删除日志为‘yyyy-mm-dd hh24:mi:ss’之前产生的所有日志      |
>
> 也可以在mysql的配置文件中配置二进制日志的过期时间，设置了之后，二进制日志过期会自动删除
>
> ```sql
> show variables like '%binlig_expire_log_seconds%'
> ```

## 查询日志

> 查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句，默认情况下，查询日志未开启，查看状态：`show variables like ‘%general%’`
>
> 如果需要开启查询日志，可以修改MySQL的配置文件`/etc/my.cnf`文件，添加如下内容：
>
> ```shell
> # 该选项用来开启查询日志，可选值：0代表关闭；1代表开启
> general_log=1
> # 设置日志的文件名，如果没有指定，默认的文件名为host_name.log
> general_log_file=mysql_query.log
> ```
>
> 开启了查询日志之后，在MySQL的数据存放目录，也就是`/var/lib/mysql/`目录下就会出现`mysql_query.log`文件。

# 主从复制

## 概述

> **主从复制是将主数据的DDL和DML操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行(也叫重做)，从而使得从库和主库的数据保持同步。**
>
> MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制
>
> MySQL复制的优点主要包含以下三个方面：
>
> * 主库出现问题，可以快速切换到从库提供服务
> * 实现读写分离，降低主库的访问压力
> * 可以在从库中执行备份，以避免备份期间影响主库服务

## 原理

> **MySQL主从复制的核心就是二进制日志**，具体过程如下：
>
> ![](.\img\221.jpg)
>
> 从上图来看，复制分称三步：
>
> * Master主库在事务提交时，会把数据变更记录在二进制日志文件Binlog中
> * 从库读取主库的二进制日志文件Binlog，写入到从库的**中继日志Relay Log**
> * **Slave重做中继日志中的事件，将改变反映它自己的数据**

## 搭建

### 主库配置

1. 修改配置文件`/etc/my.cnf`

   ```shell
   # mysql服务ID，保证整个集群环境中唯一，取值范围：1-232-1，默认为1
   server-id=1
   # 是否只读，1代表只读，0代表读写
   read-only=0
   # 忽略的数据，指不需要同步的数据库
   # binlog-ignore-db=mysql
   # 指定同步的数据库
   # binlog-do-db=xxx
   ```

2. 重启MySQL服务器

   ```shell
   systemctl restart mysqld
   ```

3. 创建远程连接的账号，并授予主从复制权限

   ```shell
   # 创建用户，并设置密码
   create user '用户名'@'%' identified with mysql_native_password by 'Root@密码';
   # 为用户分配主从复制权限
   grant replication slave on *3.* to '用户名'@'%';
   ```

4. 通过指令，查看二进制日志坐标

   ```sql
   show master status;
   ```

   > 字段含义说明：
   >
   > * file：从哪个日志文件开始推送日志文件
   > * position：从哪个位置开始推送日志
   > * binlog_ignore_db：指定不需要同步的数据库

### 从库配置

1. 修改配置文件`/etc/my.cnf`

   ```shell
   # mysql服务ID，保证整个集群环境中唯一，取值范围：1-2^32-1，和主库不一样即可
   server-id=2
   # 是否只读，1代表只读，0代表读写
   read-only=1
   ```

2. 重启MySQL服务器

   ```shell
   systemctl restart mysqld
   ```

3. 登录MySQL，设置主库配置

   * 8.0.23版本中的语法

     ```sql
     change replication source to source_host='主库IP',source_user='主库用户名',source_password='主库密码',source_log_file='binlog.xxxxxx',source_log_pos=xxx;
     ```

   * 8.0.23版本之前的语法

     ```sql
     change master to master_host='主库IP',master_user='主库用户名',master_password='主库密码',master_log_file='binlog.xxxxx',master_log_pos=xxx;
     ```

4. 开启同步操作

   * 8.0.22版本之后的操作

     ```sql
     start replica;
     ```

   * 8.0.22版本之前操作

     ```sql
     start slave;
     ```

5. 查看主从同步状态

   * 8.0.22版本之后的操作

     ```sql
     show replica status;
     ```

   * 8.0.22版本之前的操作

     ```sql
     show slave status;
     ```

# 分库分表

## 介绍

### 问题分析

> 随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存储，存在以下性能瓶颈：
>
> * IO瓶颈：热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。请求数据太多，带宽不够，网络IO瓶颈
> * CPU瓶颈：排序、分组、连接查询、聚合统计等SQL会耗费大量CPU资源，请求数太多，CPU出现瓶颈
>
> 为了解决上述问题，我们需要对数据库进行分库分表处理。**分库分表的中心思想都是将数据分散存储，使得单一数据库/表的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的。**

### 垂直拆分

#### 垂直分库

> <img src=".\img\222.jpg" style="zoom: 50%;" />
>
> **`垂直分库`：以表为依据，根据业务将不同表拆分到不同库中。**
>
> 特点：
>
> * 每个库的表结构都不一样
> * 每个库的数据也不一样
> * 所有库的并集是全量数据

#### 垂直分表

> <img src=".\img\223.jpg" style="zoom:50%;" />
>
> **`垂直分表`：以字段为依据，根据字段属性将不同字段拆分到不同表中。**
>
> 特点：
>
> * 每个表的结构都不一样
> * 每个表的数据也不一样，一般通过一列(主键/外键)关联
> * 所有表的并集是全量数据

### 水平拆分

#### 水平分库

> <img src=".\img\224.jpg" style="zoom:50%;" />
>
> **`水平分库`：以字段为依据，按照一定策略，将一个库的数据拆分到多个库中。**
>
> 特点：
>
> * 每个库的表结构都一样
> * 每个库的数据都不一样
> * 所有库的并集是全量数据

#### 水平分表

> <img src=".\img\225.jpg" style="zoom:50%;" />
>
> **`水平分表`：以字段为依据，按照一定策略，将一个表的数据拆分到多个表中。**
>
> 特点：
>
> * 每个表的表结构都一样
> * 每个表的数据都不一样
> * 所有表的并集是全量数据

> **在业务系统中，为了缓解磁盘IO和CPU的性能瓶颈，到底是垂直拆分，还是水平拆分；具体是分库，还是分表，都需要根据具体的业务需求具体分析。**

## MyCat

# 读写分离



