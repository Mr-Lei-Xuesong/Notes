# 数据结构

> **程序=数据结构+算法**
>
> **`数据结构包括`：线性结构和非线性结构**

## 线性结构

> * 线性结构作为最常用的数据结构，其特点是**数据元素之间存在一对一**的线性关系
>
> * 线性结构有两种不同的存储结构，即**顺序存储结构(数组)**和**链式存储结构(链表)**。顺序存储的线性表称为顺序表，顺序表中的**存储元素是连续**的
>
> * 链式存储的线性表称为链表，链表中的**存储元素不一定是连续的**，元素节点中存放数据元素以及相邻元素的地址信息
>
> * 线性结构常见的有：**数组、队列、链表和栈**

## 非线性结构

> * 非线性结构包括：二维数组，多维数组，广义表，**树结构，图结构**

# 稀疏数组

* 当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组
* 稀疏数组的处理方法是：
  * 第一行记录数组**一共有几行几列，有多少个不同**的值
  * 把具有不同值的元素的**行、列及值**记录在一个小规模的数组中，从而**缩小程序**的规模

![](.\img/1.jpg)

> **二维数组转稀疏数组的思路**：
>
> 1. 遍历原始的二维数组，得到有效数据的个数sum
> 2. 根据sum就可以创建稀疏数组sparseArr int [sum+1] [3]
> 3. 将二维数组的有效数据存入到稀疏数组
>
> **稀疏数组转二维数组的思路**：
>
> 1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组
> 2. 在读取稀疏数组后几行的数据，并赋予给原始的数组

# 队列

* 队列是一个**有序列表**，可以用**数组**或是**链表**来实现

* 遵循**先入先出**的原则。即：**先存入队列的数据，要先取出。后存入的要后取出**

  ![](.\img/2.jpg)

## 数组模拟队列思路

> maxSize：最大值，rear：尾部指针，front：头部指针
>
> * 当rear==front的时候，队列为空
>
> * 当rear==maxSize-1的时候，队列满
> * 当要向队列插入数据，先移动rear，根据rear的下标往数组中插入数据
> * 当要从队列中取出数据时，先移动front，根据front的下标从数组中取出数据

## 数组模拟环形队列思路

> * front变量的含义做一个调整：front就指向队列的第一个元素，array[front]就是队列的第一个元素，front的初始值=0
> * rear变量的含义做一个调整：**rear指向队列的最后一个元素的后一个位置(预留一个空位出来)**，rear的初始值=0
> * 当队列满时，条件是`(rear+1)%maxSize==front`
> * 当队列空时，条件是`rear==front`
> * 队列中的有效数据的个数为：`   (rear-front+maxSize)%maxSize`

# 链表

* 链表是有序的列表，但是它在内存中是存储如下

  ![](.\img/3.jpg)
  * 链表是以节点的方式来存储,**是链式存储**
  * 每个节点包含 data 域， next 域：指向下一个节点
  * **链表的各个节点不一定是连续存储**
  * 链表分**带头节点的链表**和**没有头节点的链表**

## 单链表

* 单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象) + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据

* 单链表(带头结点) 逻辑结构示意图如下

![](.\img/4.jpg)

## 双向链表

* 双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱

## 单向环形链表（Josepfu)

* 约瑟夫环（约瑟夫问题）是一个数学的应用问题：已知n个人（以编号1，2，3...n分别表示）按顺时针方向围坐在一张圆桌周围，每个人持有一个密码（正整数）。一开始任选一个整数作为报数上限值m，从第一个人开始顺时针自1报数，报到m时停止报数，报m的那个人出列，他的密码作为新的m值，从他在顺时针方向上的下一个人又开始重新从1报数，报到m的那个人出列又出列；依此规律重复下去，直到圆桌周围的人全部出列

# 栈

* 栈的英文为(stack)
* 栈是一个**先入后出(FILO-First In Last Out)的有序列表**
* 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。
* **最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除**
* **出栈(pop)和入栈(push)的概念**

![](.\img/5.jpg)

* 栈的应用场景
  * 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。
  * 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。
  * 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。
  * 二叉树的遍历。
  * 图形的深度优先(depth 一 first)搜索法。

## 前缀表达式(波兰表达式)

* **前缀表达式的运算符位于操作数之前，例如(3+4*5-6)对应的前缀表达式为：- * +3456**
* 前缀表达式的计算机求值
  * 从**右至左**扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果

> **`注意`：栈顶元素+-*/次顶元素**

## 中缀表达式

* 我们生活中常用的表达式，简单来讲，就是**人能算的表达式**

> **`注意`：次顶元素+-*/栈顶元素**

## 后缀表达式(逆波兰表达式)

* **后缀表达式又称逆波兰表达式，与前缀表达式相似，只是运算符位于操作符之后，例如(3+4) * 5-6对应的后缀表达式为：34+5 * 6-  **

* 从**左至右**扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

> **`注意`：次顶元素+-*/栈顶元素**

## 中缀转后缀

1. 初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2
2. 从左至右扫描中缀表达式
3. 遇到操作数时，将其压入 s2栈中
4. 遇到运算符时，比较其与 s1 栈顶运算符的优先级
   1. 如果 s1 为空，或栈顶运算符为左括号`(`，则直接将此运算符入栈
   2. 若优先级比栈顶运算符的高，也将运算符压入 s1
   3. 否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(4.1)与 s1 中新的栈顶运算符相比较
5. 遇到括号时

   1. 如果是左括号`(`，则直接压入 s1

   2. 如果是右括号`)`，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃
6. 重复步骤 2 至 5，直到表达式的最右边
7. 将 s1 中剩余的运算符依次弹出并压入 s2
8. 依次弹出 s2 中的元素并输出，**结果的逆序即为中缀表达式对应的后缀表达式**

> 将中缀表达式：`1+((2+3)*4)-5`转换为后缀表达式的结果为`123+4*+5-`
>
> ![](.\img\226.jpg)

# 递归

* 概念
  * **递归就是方法自己调用自己**,每次调用时**传入不同的变量**.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁

* 递归需要遵守的规则
  * 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
  * 方法的局部变量是独立的，不会相互影响
  * 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据
  * 递归**必须向退出递归的条件逼近**，否则就是无限递归,出现 StackOverflowError，死龟了
  * 当一个方法执行完毕，或者遇到 return，就会返回，**遵守谁调用，就将结果返回给谁**，同时当方法执行完毕或者返回时，该方法也就执行完毕

## 八皇后问题

* 在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即：**任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法** **(92)**
* 算法思路分析：
  1. 第一个皇后先放第一行第一列
  2. 第二个皇后放在第二行第一列、然后判断是否 OK， 如果不 OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适
  3. 继续第三个皇后，还是第一列、第二列……直到第 8 个皇后也能放在一个不冲突的位置，算是找到了一个正确解
  4. 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到
  5. 然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4 的步骤

# 排序

* 排序也称排序算法 (Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程

## 排序分类

* 内部排序：指将需要处理的所有数据都加载到内部存储器中进行排序

* 外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序

* 常见的排序算法分类

  ![](.\img/6.jpg)

## 冒泡排序

* 冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,**依次比较相邻元素的值，若发现逆序则交换**，使值较大的元素逐渐从前移向后部，每一趟排完序，最后的位置就确定，下次就减少一个位置，就象水底下的气泡一样逐渐向上冒

## 选择排序

* 选择式排序也属于内部排序法，是从预排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的
* 选择排序思想
  * 选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从 arr[0]~arr[n-1]中选取最小值，与 arr[0]交换，第二次从 arr[1]~arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]~arr[n-1]中选取最小值，与 arr[2]交换，…，第 i 次从 arr[i-1]~arr[n-1]中选取最小值，与 arr[i-1]交换，…, 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值，与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列

## 插入排序

* 插入式排序属于内部排序法，是对于预排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的
* 插入排序思想
  * 插入排序（Insertion Sorting）的基本思想是：**把** **n 个待排序的元素看成为一个有序表和一个无序表**，开始时**有序表中只包含一个元素**，无序表中包含有 **n-1 个元素**，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表

## 希尔排序

* 希尔排序也是一种**插入排序**，它是简单插入排序经过改进之后的一个**更高效的版本**，也称为**缩小增量排序**

* 希尔排序思想

  * 希尔排序是把记录按下标的一定增量(步长)分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，**当增量减至** **1** **时**，整个文件恰被分成一组，算法便终止

    ![](.\img/9.jpg)

## 快速排序

* 快速排序（Quicksort）是对**冒泡排序**的一种改进。

* 快速排序思想

  * **通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小**，然后再按此方法对这两部分数据分别进行快速排序，**整个排序过程可以递归进行**，以此达到整个数据变成有序序列

    ![](.\img/10.jpg)

## 归并排序

* 归并排序（MERGE-SORT）是利用分治的思想实现的排序方法

* 归并排序思想

  * 该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)

    ![](.\img/11.jpg)

<img src=".\img/12.jpg" style="zoom: 200%;" />

<img src=".\img/13.jpg" style="zoom:200%;" />

## 基数排序

* 基数排序（radixsort）属于“分配式排序”（distributionsort），又称“桶子法”（bucketsort）或binsort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用
* 基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法
* 基数排序(RadixSort)是桶排序的扩展
* 基数排序思想
  * **将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列**
* 基数排序说明
  * 基数排序是对传统桶排序的扩展，速度很快
  * 基数排序是经典的空间换时间的方式，占用内存很大,当对海量数据排序时，容易造`OutOfMemoryError`
  * 基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的
  * **有负数的数组，我们不用基数排序来进行排序**

## 堆排序

* 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序

* 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆,注意:没有要求结点的左孩子的值和右孩子的值的大小关系

* 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆

* 大顶堆

  ![](.\img/19.jpg)

  ![](.\img/20.jpg)

  * 大顶堆特点：**arr[i] >=arr[2\*i+1] &&arr[i] >=arr[2\*i+2]** //i对应第几个节点，i从0开始编号

* 小顶堆

  ![](.\img/21.jpg)

  * 小顶堆特点：**arr[i] <=arr[2\*i+1] &&arr[i] <=arr[2\*i+2]** //i对应第几个节点，i从0开始编号

* 一般**升序采用大顶堆**，**降序采用小顶堆**

* 堆排序思想

  * 将无序序列构建成一个堆，根据升序降序需求选择大顶堆(或小顶堆)

  * 此时，整个序列的最大值就是堆顶的根节点。

  * 将其与末尾元素进行交换，此时末尾就为最大值

  * 然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了 


## 排序算法对比

![](.\img/14.jpg)

* 相关术语
  * 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面
  * 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面
  * 内排序：所有排序操作都在内存中完成
  * 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行
  * 时间复杂度：一个算法执行所耗费的时间
  * 空间复杂度：运行完一个程序所需内存的大小
  * n:数据规模
  * k:“桶”的个数
  * In-place:不占用额外内存 
  * Out-place:占用额外内存

# 算法的时间复杂度

* 度量一个程序(算法)执行时间的两种算法
  * 事后统计的方法
    * 这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素。**这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快**
  * 事前估算的方法
    * 通过分析某个算法的**时间复杂度**来判断哪个算法更优

* 时间频度
  * 一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的**语句执行次数**称为**语句频度或时间频度**。**记为 T(n)**
  * **可忽略常数项、低次项、系数**

* **时间复杂度**
  
  * 一般情况下，**算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数**，用 T(n)表示，若有某个辅助函数 f(n)，使得当 n 趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称 f(n)是 T(n)的同数量级函数。记作 **T(n)=Ｏ( f(n) )**，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度
  * T(n) 不同，但时间复杂度可能相同
  * **计算时间复杂度的方法**
    * 用常数 1 代替运行时间中的所有加法常数 `T(n)=n²+7n+6 => T(n)=n²+7n+1`
    * 修改后的运行次数函数中，只保留最高阶项 `T(n)=n²+7n+1 => T(n) = n²`
  * 去除最高阶项的系数 `T(n) = n² => T(n) = n² => O(n²)`
  
* 常见的时间复杂度
  * 常数阶 O(1)
  * 对数阶 O(log~2~n)
  * 线性阶 O(n)
  * 线性对数阶 O(nlog~2~n)
  * 平方阶 O(n^2^)
  * 立方阶 O(n^3^)
  * k 次方阶 O(n^k^)
  * 指数阶 O(2^n^)
  * **常见的时间复杂度对应的图**:

  ![](.\img/7.jpg)
  * 说明：
    * 常见的算法时间复杂度由小到大依次为：**Ο(1)＜Ο(log~2~n)＜Ο(n)＜Ο(nlog~2~n)＜Ο(n^2^)＜Ο(n^3^)＜ Ο(n^k^) ＜Ο(2^n^)**，随着问题规模 n 的不断增大，上述时间复杂度不断增大，算法的执行效率越低

* 平均时间复杂度和最坏时间复杂度

  * 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间

  * 最坏情况下的时间复杂度称最坏时间复杂度。**一般讨论的时间复杂度均是最坏情况下的时间复杂度**。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。

  * 平均时间复杂度和最坏时间复杂度是否一致，和算法有关

    ![](.\img/8.jpg)

* 算法的空间复杂度
  * 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模 n 的函数
  * 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模 n 有关，它随着 n 的增大而增大，当 n 较大时，将占用较多的存储单元，例如**快速排序**和**归并排序算法, 基数排序**就属于这种情况
  * 在做算法分析时，主要讨论的是时间复杂度。**从用户使用体验上看，更看重的程序执行的速度**。一些缓存产品(redis, memcache)和算法(基数排序)**本质就是用空间换时间**

# 查找算法

## 线性查找 

* 从第一个记录开始，逐个比较记录的关键字，直到和给定的value值相等，则查找成功；若比较结果与文件中n个记录的关键字都不等，则查找失败

## 二分法查找(递归)

* 二分法查找适用于数据量较大时，**但是数据需要先排好顺序**
* 二分法查找思想
  * 确定该区间的中间位置mid   `mid=(left+right)/2`
  * 将查找的值value与array[mid]比较。若相等，查找成功返回此位置；否则确定新的查找区域，继续二分查找。每一次查找与中间值比较，可以确定是否查找成功，不成功当前查找区间将缩小一半，递归查找即可
  * 区域确定如下：
    * value<array[mid]，故新的区间为array[left,……,mid-1]
    * value>array[mid]，故新的区间为array[mid+1,……,right]。

## 插值查找

* 插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找
* 插值查找算法公式：**`int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left])`**

* 插值查找注意事项
  * **对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找,速度较快**
  * **关键字分布不均匀的情况下，该方法不一定比折半查找要好**

## 斐波那契(黄金分割法)查找算法

* 黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比

* 斐波拉契查找算法原理

  * mid=low+F(k-1)-1（F代表斐波那契数列)

    ![](.\img/15.jpg)

# 哈希表

* 散列表（Hashtable，也叫哈希表），是根据关键码值(Keyvalue)而直接进行访问的**数据结构**。它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表

  ![](.\img/16.jpg)

# 树

* 为什么需要树这种数据结构
  * 数组存储方式的分析
    * 优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度
    * 缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低
  * 链式存储方式的分析
    * 优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可，删除效率也很好)
    * 缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历)
  * 树存储方式的分析
    * 能提高数据存储，读取的效率,比如利用二叉排序树(BinarySortTree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度

## 树的示意图

![](.\img/17.jpg)

* 树的常用术语
  * 节点
  * 根节点
  * 父节点
  * 子节点
  * 叶子节点(没有子节点的节点)
  * 节点的权(节点值)
  * 路径(从root节点找到该节点的路线)
  * 层
  * 子树
  * 树的高度(最大层数)
  * 森林:多颗子树构成森林

## 二叉树

* 概念
  * 每个节点最多只能有两个子节点的一种形式称为二叉树
  * 二叉树的子节点分为左节点和右节点
  * 如果该二叉树的所有叶子节点都在最后一层，并且`结点总数=2^n-1`,n为层数，则我们称为**满二叉树**
  * 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为**完全二叉树**


## 前中后遍历

* **`前序遍历`:先输出父节点，再遍历左子树和右子树**
* **`中序遍历`:先遍历左子树，再输出父节点，再遍历右子树**
* **`后序遍历`:先遍历左子树，再遍历右子树，最后输出父节点**
* **`小结`**:**看输出父节点的顺序，就确定是前序，中序还是后序**

> * 前序遍历思路
>   * 先输出当前节点(初始节点为根节点)
>   * 如果左子节点不为空，则递归继续前序遍历
>   * 如果右子节点不为空，则递归继续前序遍历
> * 中序遍历思路
>   * 如果当前节点的左子节点不为空，则递归中序遍历
>   * 输出当前节点
>   * 如果当前节点的右子节点不为空，则递归中序遍历
> * 后序遍历思路
>   * 如果当前节点的左子节点不为空，则递归后序遍历
>   * 如果当前节点的右子节点不为空，则递归后序遍历
>   * 输出当前节点

> * 前序查找思路
>   * 先判断当前节点的是否等于要查找的，如果相等，则返回当前节点
>   * 如果不相等，则判断当前节点的左子节点是否为空，如果不为空，则递归前序查找，找到需要查询的节点就返回
>   * 如果不相等，则判断当前节点的右子节点是否为空，如果不为空，则递归前序查找，找到需要查询的节点就返回
> * 中序查找思路
>   * 判断当前节点的左子节点是否为空，如果不为空，则递归中序查找，如果找到，则返回
>   * 如果没有找到，就和当前节点比较是否相等，相等就返回当前节点
>   * 如果不相等，判断当前节点的右子节点是否为空，如果不为空，则递归中序查找
> * 后序查找思路
>   * 判断当前节点的左子节点是否为空，如果不为空，则递归后序查找，如果找到，则返回
>   * 如果没有找到，就判断当前节点的右子节点是否为空，如果不为空，则递归后序查找
>   * 如果没有找到，就和当前节点进行比较，如果相等就返回，否则返回为null

> > **因为二叉树是单向的，所以我们是判断`当前节点的子节`点是否是需要删除的节点**
>
> * 删除节点思路：`如果是叶子节点，就直接删除；如果非叶子节点，就直接删除该子树`
>   * 先判断树是不是空树，如果要删除的节点等于根节点，就直接置空根节点
>   * 如果当前节点的左子节点不为空，并且左子节点就是要删除的节点，就将左子节点置空，并返回
>   * 如果当前节点的右子节点不为空，并且右子节点就是要删除的节点，就将右子节点置空，并返回
>   * 如果前两步都没找到要删除节点，就需要向左子节点递归删除
>   * 左子节点递归都没找到要删除的，则应向右子节点递归删除
> * 删除节点思路：`如果是叶子节点，就直接删除；如果非叶子节点，就删除该节点，并把左子节点移动到删除节点位置`
>   * 先判断树是不是空树，如果要删除的节点等于根节点，就直接置空根节点
>   * 如果当前节点的左子节点不为空，并且左子节点就是要删除的节点，就继续判断当前节点的左子节点的左子节点是否为空，如果为空就直接置空当前节点的左子节点，如果不为空，就继续判断当前节点的左子节点的右子节点是否为空，如果不为空，就把它暂存到一个临时变量里面，然后把当前节点的左子节点的左子节点赋值给当前节点的左子节点，然后把临时变量赋值给当前节点的左子节点的左子节点
>   * 如果当前节点的右子节点不为空，并且右子节点就是要删除的节点，就继续判断当前节点的右子节点的左子节点是否为空，如果为空就直接置空当前节点的右子节点，如果不为空，就继续判断当前节点的右子节点的右子节点是否为空，如果不为空，就把它暂存到一个临时变量里面，然后把当前节点的右子节点的左子节点赋值给当前节点的右子节点，然后把临时变量赋值给当前节点的右子节点的左子节点
>   * 如果前两步都没找到要删除节点，就需要向左子节点递归删除
>   * 左子节点递归都没找到要删除的，则应向右子节点递归删除

## 顺序存储二叉树

* 概念
  * **数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组**

---

* 顺序存储二叉树的特点:

  * **顺序存储二叉树通常只考虑完全二叉树**
  * 第n个元素的左子节点为 2 * n + 1
  * 第n个元素的右子节点为 2 * n + 2
  * 第n个元素的父节点为 (n-1) / 2 
  * **n : 表示二叉树中的第几个元素(按0开始编号)**

  ![](.\img/18.jpg)

## 线索化二叉树

* **n个结点的二叉链表中含有`n+1`个空指针域**。利用二叉链表中的空指针域，存放指向**该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为"线索"）**
* 这种**加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(ThreadedBinaryTree)**。根据线索性质的不同，线索二叉树可分为**前序线索二叉树、中序线索二叉树和后序线索二叉树**三种
* 一个结点的前一个结点，称为**前驱**结点
* 一个结点的后一个结点，称为**后继**结点

> ![](.\img\227.jpg)
>
> 当线索化二叉树后，Node节点的属性left和right，有如下情况：
>
> * left指向的是左子节点，也可能是指向的前驱节点，比如1节点left指向的是左子节点3，而10节点的left指向的就是前驱节点3
> * right指向的是右子节点，也可能是指向后继节点，比如1节点right指向的是右子节点6，而10节点的right指向的是后继节点1     

## 哈夫曼树

* 给定n个权值作为n个叶子结点，构造一棵二叉树，**若该树的带权路径长度(wpl)达到最小**，称这样的二叉树为最优二叉树，也称为哈夫曼树(HuffmanTree)
* **哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近**
* **路径和路径长度**
  * 在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。**通路中分支的数目称为路径长度**。**若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1**
* **结点的权及带权路径长度**
  * 若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：**从根结点到该结点之间的路径长度与该结点的权的`乘积`**
* 树的带权路径长度
  * 树的带权路径长度规定为**所有叶子结点的带权路径长度之和**，记为WPL(weighted path length),权值越大的结点离根结点越近的二叉树才是最优二叉树

> 构成哈夫曼树的步骤：
>
> 1. 将数列从小到大进行排序，每个数据都是一个节点，每个单独的节点看成一颗最简单的二叉树
> 2. 取出数列中权值最小的两个节点构成一颗二叉树
> 3. 该新的二叉树的根节点的权值，是前面两颗二叉树权值的和
> 4. 再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1，2，3，4的步骤，直到数列中所有的数据都被处理，就得到一颗哈夫曼树

## 二叉排序树

* **BST:(Binary Sort(Search) Tree)**,对于二叉排序树的**任何一个非叶子节点**，**要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大**

  * 如果有相同的值，可以将该节点放在左子节点或右子节点

  ![](.\img/22.jpg)

* **删除节点思路**

> **删除叶子节点** (比如：2,5,9,12)
>
> 1. 先去找到要删除的结点targetNode
> 2. 找到targetNode的父结点parentNode
> 3. 确定targetNode是parentNode的左子结点还是右子结点
> 4. 根据前面的情况来对应删除
>    1. 左子结点parent.left=null
>    2. 右子结点parent.right=null
>
> **删除只有一颗子树的节点** (比如：1)
>
> 1. 先去找到要删除的结点targetNode
>
> 2. 找到targetNode的父结点parentNode
>
> 3. 确定targetNode的子结点是左子结点还是右子结点
>
> 4. targetNode是parentNode的左子结点还是右子结点
>
> 5. 如果targetNode有左子节点
>
>    1. 如果targetNode是parentNode的左子节点
>
>       `parentNode.left=targetNode.left`
>
>    2. 如果targetNode是parentNode的右子节点
>
>       `parentNode.right=targetNode.left`
>
> 6. 如果targetNode有右子节点
>
>    1. 如果targetNode是parentNode的左子节点
>
>       `parentNode.left=targetNode.right`
>
>    2. 如果targetNode是parentNode的右子节点
>
>       `parentNode.right=targetNode.right`
>
> **删除有两颗子树的节点** (比如：7,3，10)
>
> 1. 需求先去找到要删除的结点targetNode
> 2. 找到targetNode的父结点parent
> 3. 从targetNode的右子树找到最小的结点(**左子树找最大的，右子树找最小的**)
> 4. 用一个临时变量，将最小结点的值保存tempNode
> 5. 删除该最小结点
> 6. targetNode.value=tempNode.value

## 平衡二叉树(AVL树)

* 平衡二叉树也叫**平衡二叉搜索树**（Self-balancingbinarysearchtree）又被称为AVL树，可以保证查询效率较高
* 它是一棵**空树**或**它的左右两个子树的高度差的绝对值不超过1**，并且**左右两个子树都是一棵平衡二叉树**

* **左旋转**：当右子树减去左子树的绝对值大于1时，就左旋转

  > 1. 创建新的结点，以当前根结点的值
  > 2. 把新的结点的左子树设置成当前结点(根节点)的左子树
  > 3. 把新的结点的右子树设置成当前结点(根节点)的右子树的左子树
  > 4. 把当前结点的值替换成右子结点的值
  > 5. 把当前结点的右子树设置成当前结点(根节点)右子树的右子树
  > 6. 把当前结点(根节点)的左子树设置成新建立的结点
* **右旋转**

  > 1. 创建新的结点，以当前根结点的值
  > 2. 把新的结点的右子树设置成当前结点的右子树
  > 3. 把新的结点的左子树设置成当前结点的左子树的右子树
  > 4. 把当前结点的值替换成左子结点的值
  > 5. 把当前结点的左子树设置成当前结点左子树的左子树
  > 6. 把当前结点的右子树设置成新建立的结点
* **双旋转**

  > * 当符合右旋转的条件时
  > * 如果当前的左子树的右子树高度大于左子树高度，就先对左子树进行左旋转
  > * 再对当前节点进行右旋转
  >
  > ------
  >
  > * 当符合左旋转的条件时
  >
  > * 如果当前的右子树的左子树高度大于右子树高度，就先对右子树进行右旋转
  > * 再对当前节点进行左旋转

# 多路查找树

* **在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiwaytree）**

## B树 

* 规则:
  1. 排序方式：**所有节点关键字是按递增次序排列，并遵循左小右大原则**
  2. 子节点数：非叶节点的子节点数>1，且<=M ，且M>=2，空树除外（注：M阶代表一个树节点**最多**有多少个查找路径，M=M路,当M=2则是2叉树,M=3则是3叉树）
  3. 所有叶子节点均在同一层
  4. **关键字：关键字集合分布在整颗树中,即叶子节点和非叶子节点都存放数据**
  5. B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点

## B+树

* B+树是B-树的变体，也是一种多路搜索树，其定义基本与B树相同

* **B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加，非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层**

* 所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的

* B+树**叶子**节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样

* B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针

  ![](.\img/23.jpg)

## B*树

* B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针

* B*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3，而B+树的块的最低使用率为的1/2

  ![](.\img/24.jpg)

## 2-3树

* 2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)
* 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点
* 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点
* 2-3树是由二节点和三节点构成的树

## 红黑树

* 红黑树是一种平衡二叉查找树的变体，它的左右子树高差有可能大于 1，所以红黑树不是严格意义上的平衡二叉树（AVL），但 对之进行平衡的代价较低， 其平均统计性能要强于 AVL 
* 红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：
  * 性质1：每个节点要么是黑色，要么是红色
  * 性质2：根节点是黑色
  * 性质3：每个叶子节点（NIL）是黑色
  * 性质4：每个红色结点的两个子结点一定都是黑色
  * **性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点**
* 红黑树的自平衡靠**左旋、右旋和变色**
  * **左旋**：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变
  * **右旋**：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变
  * **变色**：结点的颜色由红变黑或由黑变红

# 图

* 图是一种**数据结构**，其中结点可以具有零个或多个相邻元素。**两个结点之间的连接称为边。结点也可以称为顶点**

* 图分类：
  * 有向图
  * 无向图
  * 带权图
  
* 图的表示方式：
  * **二维数组表示(邻接矩阵)**
    
    * 邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是row和col表示的是1....n个点
    
      ![](.\img\228.jpg)
  * **链表表示(邻接表)**
    
    * 邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失
    
    * 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，**邻接表由数组+链表组成**
    
      ![](.\img\229.jpg)

## 图的遍历

* 图的遍历，即是对结点的访问

* **深度优先搜索(DepthFirstSearch)**

  * 深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，**深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点**，可以这样理解：**每次都在访问完当前结点后首先访问当前结点的第一个邻接结点**

    ![](.\img\230.jpg)

  * 思路步骤
    > 1. 访问初始结点i，并标记结点i为已访问
    > 2. 查找结点i的第一个邻接结点j
    > 3. 若j存在，则继续执行4，如果j不存在，则回到第1步，将从i的下一个结点继续
    > 4. 若j未被访问，对j进行深度优先遍历递归（即把j当做另一个i，然后进行步骤123）
    > 5. 查找结点i的j邻接结点的下一个邻接结点 ，转到步骤3

* **广度优先搜索(BroadFirstSearch)**

  * 类似于一个分层搜索的过程，**广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点**

    ![](.\img\231.jpg)

  * 思路步骤
    > 1. 访问初始结点i并标记结点i为已访问
    > 2. 结点i入队列
    > 3. 当队列非空时，继续执行，否则算法结束
    > 4. 出队列，取得队头结点headIndex
    > 5. 查找结点headIndex的第一个邻接结点w
    > 6. 若结点headIndex的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤
    >    1. 若结点w尚未被访问，则访问结点w并标记为已访问
    >    2. 结点w入队列
    >    3. 查找结点headIndex的继w邻接结点后的下一个邻接结点w，转到步骤6

# 常用算法

## 二分法查找

* 二分法查找适用于数据量较大时，**但是数据需要先排好顺序**
* 二分法查找思想
  * while(left<=right)
  * 确定该区间的中间位置mid   `mid=(left+right)/2`
  * 将查找的值value与array[mid]比较。若相等，查找成功返回此位置；否则确定新的查找区域，继续二分查找。每一次查找与中间值比较，可以确定是否查找成功，不成功当前查找区间将缩小一半，递归查找即可
  * 区域确定如下：
    * right=mid-1
    * left=mid+1

## 分治算法

* 分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题......直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。
* 分治法在每一层递归上都有三个步骤
  * 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题
  * 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
  * 合并：将各个子问题的解合并为原问题的解 

## 动态规划算法

* 动态规划(DynamicProgramming)算法的核心思想是：将**大问题划分为小问题**进行解决，从而一步步获取最优解的处理算法
* 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解
* 与分治法不同的是，适合于用动态规划求解的问题，经分解得到**子问题往往不是互相独立的(即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解)**
* 动态规划可以通过填表的方式来逐步推进，得到最优解

## KMP算法

* Knuth-Morris-Pratt字符串查找算法，简称为“KMP算法”，常用于在一个文本串S内查找一个模式串P的出现位置

* KMP的next 数组相当于告诉我们：**当模式串中的某个字符跟文本串中的某个字符匹配失配时，模式串下一步应该跳到哪个位置**。如模式串中在j 处的字符跟文本串在i 处的字符匹配失配时，下一步用next [j] 处的字符继续跟文本串i 处的字符匹配，相当于模式串向右移动 **j - next[j]** 位

* **移动位数=已匹配的字符数-对应的部分匹配值**

  ![](.\img/25.jpg)

> 部分匹配表的产生：前缀、后缀是什么
>
> 例：字符串：“bread”
>
> * 前缀：b、br、bre、brea
>
> * 后缀：read、ead、ad、d
>
> “部分匹配值”就是“前缀”和“后缀”的最长的共有元素的长度。以“ABCDABD”为例
>
> * “A”的前缀和后缀都为空集，共有元素的长度为0
> * “AB”的前缀为[A]，后缀为[B]，共有元素的长度为0
> * “ABC”的前缀为[A，AB]，后缀为[BC，C]，共有元素的长度0
> * “ABCD”的前缀为[A，AB，ABC]，后缀为[BCD，CD，D]，共有元素的长度为0
> * “ABCDA”的前缀为[A，AB，ABC，ABCD]，后缀为[BCDA，CDA，DA，A]，共有元素为“A”，长度为1
> * “ABCDAB”的前缀为[A，AB，ABC，ABCD，ABCDA]，后缀为[BCDAB，CDAB，DAB，AB，B]，共有元素为“AB”，长度为2
> * “ABCDABD”的前缀为[A，AB，ABC，ABCD，ABCDA，ABCDAB]，后缀为[BCDABD，CDABD，DABD，ABD，BD，D]，共有元素的长度为0

## 贪心算法

* 贪婪算法(贪心算法)是指在对问题进行求解时，**在每一步选择中都采取最好或者最优(即最有利)的选择**，从而希望能够导致结果是最好或者最优的算法
* 贪婪算法所得到的结果**不一定是最优的结果(有时候会是最优解)**，但是都是相对近似(接近)最优解的结果
* 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关

## 最小生成树

* 最小生成树(MinimumCostSpanningTree)，简称MST。给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树
* N个顶点，一定有N-1条边
* 包含全部顶点
* N-1条边都在图中

* **最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法**

## 普里姆(Prim)算法

* 普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图

  ![](.\img/26.jpg)

* 从图中某一个顶点出发(这里选`V0`)，寻找它相连的**所有结点**，比较这些结点的**权值大小**，然后连接**权值最小**的那个结点。（这里是`V1`）

* 然后将寻找这**两个结点**相连的**所有结点**，找到**权值最小**的连接。（这里是`V5`)

* 重复上一步，知道所有结点都连接上

  ![](.\img/27.jpg)

## 克鲁斯卡尔(Kruskal)算法

* 克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法
* 基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路
* 具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止

## 迪杰斯特拉(Dijkstra)算法

* 迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止
* 迪杰斯特拉最最朴素的思想就是按长度递增的次序产生最短路径。即每次对所有可见点的路径长度进行排序后，选择一条最短的路径，这条路径就是对应顶点到源点的最短路径

* 算法过程
  * 设置出发顶点为v，顶点集合V{v1,v2,vi...}，v到V中各顶点的距离构成距离集合Dis，Dis{d1,d2,di...}，Dis集合记录着v到图中各顶点的距离(到自身可以看作0，v到vi距离对应为di)
  * 从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时的v到vi即为最短路径
  * 更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为vi，表明是通过vi到达的)
  * 重复执行两步骤，直到最短路径顶点为目标顶点即可结束

## 弗洛伊德(Floyd)算法

* 弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法
* 核心思想
  * 设置顶点vi到顶点vk的最短路径已知为Lik，顶点vk到vj的最短路径已知为Lkj，顶点vi到vj的路径为Lij，则vi到vj的最短路径为：min((Lik+Lkj),Lij)，vk的取值为图中所有顶点，则可获得vi到vj的最短路径
  * 