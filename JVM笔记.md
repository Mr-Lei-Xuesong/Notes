# Java及JVM简介

## Java：跨平台语言

> ![](.\img\234.jpg)

## JVM：跨语言的平台

> <img src=".\img\235.jpg" style="zoom:67%;" />
>
> * **Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件**。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，他就是一个有效地字节码文件，就能够被虚拟机所识别并装载运行

## 字节码

> * 我们平常说的java字节码，指的是用java语言变异成的字节码。准确的说任何能在JVM平台上执行的字节码格式都是一样的。所以应该统称为：JVM字节码
> * 不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行
> * Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式–class字节格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes)和符号表，还有一些其他辅助信息。

## Java虚拟机

> * Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。
> * JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回收器，以及可靠的即时编译器。
> * Java技术的核心就是Java虚拟机（JVM, Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。
>
> * 作用
>   * Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细的定义，如怎么取操作数，处理结果放在哪里
> * 特点
>   * 一次编写，到处运行
>   * 自动内存管理，垃圾回收功能
>   * 数组下标越界检查
>   * 多态
>
> <img src=".\img\232.jpg" style="zoom:67%;" />

## JVM的整体结构

> * HotSpot VM是目前市面上高性能虚拟机的代表作之一
>
> * 它采用解释器与即时编译器并存的架构
>
>   ![](.\img\236.jpg)

## Java代码的执行过程

> ![](.\img\237.jpg)

## JVM的生命周期

> * 虚拟机的启动：**Java虚拟机的启动是通过引导类加载器(bootstrap class loader)创建一个初始类（initial class)来完成的**，这个类是由虚拟机的具体实现指定的。
> * 虚拟机的执行
>   * 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。
>   * 程序开始执行时它才运行，程序结束时它就停止。
>   * 执行一个所谓的Java程序的时候，真真正正的执行的是一个叫做Java虚拟机的进程。
> * 虚拟机的退出
>   * 程序正常执行结束。
>   * 程序在执行过程中遇到了异常或错误而异常终止。
>   * 由于操作系统出现错误而导致Java虚拟机进程终止。
>   * 某线程调用Runtime类或System类的exit方法，或Runtime来的halt方法，并且Java安全管理器也允许这次exit或halt操作。

# 内存结构

> ![](.\img\238.jpg)

## 程序计数器

> Program Counter Register程序计数器(寄存器)
>
> * 作用：
>   * **存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令**
> * 特点：
>   * 每个线程都有它自己的程序计数器，**是线程私有的**，生命周期与线程的生命周期保持一致
>     * 每个线程在创建后，都会产生自己的程序计数器或栈帧，程序计数器在各个线程之间互不影响。
>   * 不会存在内存溢出

## 虚拟机栈

> Java Virtual Machine Stacks(Java虚拟机栈)
>
> * 每个线程运行时所需要的内存，称为虚拟机栈
> * 每个栈由多个栈帧(Frame)组成，对应着每次方法调用时所占用的内存
> * 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

> 1. **垃圾回收是否涉及栈内存**？
>    * 不涉及，栈内存是一次次方法的调用所产生的栈帧内存，栈帧内存在每次调用结束后都会弹出栈，被自动回收掉，不需要垃圾回收来管理栈内存
> 2. **栈内存分配越大越好吗**？
>    * 栈内存划分越大，线程数会减少
> 3. **方法内的局部变量是否线程安全**？
>    * 如果方法内局部变量没有逃离方法的作用域访问，它是线程安全的
>    * 如果是局部变量引用了对象，并逃离方法的作用域范围，需要考虑线程安全

### 栈内存溢出

* 栈帧过多导致栈内存溢出
* 栈帧过大导致栈内存溢出

### 线程运行诊断

> 问题：CPU占用过多
>
> * 用`top`定位哪个进程对CPU的占用过高
>
> * `ps H -eo pid,tid,%cpu | grep 进程id` 用ps命令进一步定位是哪个线程引起的cpu占用过高
> * `jstack 进程id`可以根据进程id找到有问题的线程，进一步定位到问题代码的源码行号

## 本地方法栈

> * Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。
> * 本地方法栈，也是线程私有的
> * 本地方法是使用C语言实现的
> * 当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。
>   * 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区
>   * 它甚至可以直接使用本地处理器中的寄存器
>   * 直接从本地内存的堆中分配任意数量的内存
> * 并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈

## 堆

> * 一个JVM实例只存在一个堆内存，**堆也是Java内存管理的核心区域**
> * Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间
>   * 堆内存的大小是可以调节的
>   * `-Xms`用于表示堆区的起始内存
>   * `-Xmx`则用于表示堆区的最大内存
> * 通过`new`关键字，创建对象都会使用堆内存
> * 数组和对象可能永远不会存储在栈上，因为**栈帧中保存引用，这个引用指向对象或数组在堆中的位置**
> * 特点：
>   * 它是线程共享的，堆中对象都需要考虑线程安全的问题
>   * **有垃圾回收机制**

### 堆内存诊断

> 1. jps工具
>    * 查看当前系统中有哪些Java进程
> 2. jmap工具
>    * 查看堆内存占用情况`jmap -heap 进程id`
> 3. jconsole工具
>    * 图形界面的，多功能的检测工具，可以连续监测
> 4. jvisualvm工具
>    * 可视化展示虚拟机内容，可以对堆内存进行dump

## 方法区

> ![](.\img\239.jpg)
>
> * 存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括类和实例初始化和接口初始化中使用的特殊方法
> * 方法区与堆一样，是各个线程共享的内存区域
> * 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的
> * 方法区的大小决定了系统可以保存多少个类。如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出OOM
> * **方法区只是一种规范，永久代(1.8版本以前)和元空间(1.8版本及以后)是它的实现**

### 运行时常量池

* 二进制字节码的组成：类的基本信息、常量池、类的方法定义(包含了虚拟机指令)

* 通过反编译对应类的.class文件来查看类的信息

  * `javap -v 类名.class`

  * 类的基本信息

    ![](.\img\240.jpg)

  * 常量池

    ![](.\img\241.jpg)

  * 虚拟机中执行编译的方法(框内的是真正编译执行的内容，#号的内容需要在常量池中查找)

    ![](.\img\242.jpg)

> * **常量池**
>   * 就是一张表(Constant pool)，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息
> * 运行时常量池
>   * 常量池是.class文件中的，当该**类被加载以后，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址**

### StringTable特性

> * 常量池中的字符串仅是符号，只有**在被用到时才会转化为对象**
> * 利用串池的机制，来避免重复创建字符串对象
> * 字符串**变量拼接**的原理是**StringBuilder**
> * 字符串**常量拼接**的原理是**编译器优化**
> * 可以使用**intern方法**，主动将串池中还没有的字符串对象放入串池中
>   * 将字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，两种方式都会把串池中的对象返回
>   * **注意**：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象
> * **注意**：无论是串池还是堆里面的字符串，都是对象

### StringTable垃圾回收

> StringTable在内存紧张时，会发生垃圾回收

### StringTable调优

> 因为StringTable是由HashTable实现的，所以可以适当增加HashTable桶的个数，来减少字符串放入串池所需要的时间
>
> `-XX:StringTableSize=xxx`
>
> 考虑是否需要将字符串对象入池，可以通过**intern方法减少重复入池**

## 直接内存

> * 属于操作系统，常见于NIO操作时，**用于数据缓冲区**
> * 分配回收成本较高，但读写性能高
> * 不受JVM内存回收管理

* 文件读写流程

  > ![](.\img\243.jpg)

* 使用DirectBuffer

  > ![](.\img\244.jpg)
  >
  > * **直接内存是操作系统和Java代码都可以访问的一块区域**，无需将资源从系统内存复制到Java堆内存，从而提高了效率

* 释放原理

  > * 直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过**unsafe.freeMemory**来手动释放
  > * ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存

# 垃圾回收

## 如何判断对象可以回收

### 引用计数法

> 当一个对象被引用时，就对其计数+1，没有引用时就-1，当对象计数为0时，就可以被垃圾回收
>
> 弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放
>
> ![](.\img\245.jpg)

### 可达性分析算法

> * Java虚拟机的垃圾回收期通过可达性分析来探索所有存活的对象
> * 扫描堆中的对象，看能否**沿着GC Root对象为起点的引用链找到该对象，如果找不到，则表示可以回收**
> * 可以作为GC Root的对象
>   * 虚拟机栈(栈帧中的本地变量表)中引用的对象
>   * 方法区中类静态属性引用的对象
>   * 方法区中常量引用的对象
>   * 本地方法栈中JNI(即一般说的Native方法)引用的对象

### 五种引用

> ![](.\img\246.jpg)
>
> * 强引用
>   * 只有所有的GC Root对象都不通过**强引用**引用该对象，该对象才能被垃圾回收
>   * 如上图B、C对象都不引用A1对象时，A1对象才会被回收
> * 软引用
>   * **仅有软引用引用该对象时**，在垃圾回收后，**内存仍不足**时会载次触发垃圾回收，回收软引用对象
>   * 如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收
>   * 如果再垃圾回收时发现内存不足，再回收软引用所指向的对象时，软引用本身不会被清理
>   * 如果想要清理软引用，需要使用引用队列：查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除
> * 弱引用
>   * 只有弱引用引用该对象时，在垃圾回收时，**无论内存是否充足**，都会回收弱引用所引用的对象
>   * 如上图如果B对象不再引用A3对象，则A3对象会被回收
> *  虚引用
>   * 当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法
>   * 虚引用的一个体现是**释放直接内存所分配的内存**，如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存
> * 终结器引用
>   * 所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了
>   * 如上图，B对象不再引用A4对象。这时终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象，然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了
>
> ------
>
> * 引用队列
>   * 软引用和弱引用**可以配合**引用队列
>     * 在弱引用和虚引用所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象
>   * 虚引用和终结器引用**必须配合**引用队列
>     * 虚引用和终结器引用在使用时会关联一个引用队列

## 垃圾回收算法

### 标记清理(Mark Sweep)

> ![](.\img\247.jpg)
>
> * **`定义`**：**标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆空间腾出相应的空间**
>   * 这里腾出内存空间并不是将内存空间的字节清零，而是记录下这段内存的起始地址结束地址，下次分配内存的时候，会直接**覆盖**这段内存
> * 缺点：容易产生大量的内存碎片，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致JVM启动GC，一旦启动GC，我们的应用程序就会暂停，这就导致应用的响应速度变慢
> * **`总结`**：**速度较快，会造成内存碎片**

### 标记整理(Mark Compact)

> ![](.\img\248.jpg)
>
> * 整理标记会将不被GC Root引用对象回收，清除其占用的内存空间，然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整理需要消耗一定的时间，所以效率较低
> * **`总结`**：**速度慢，没有内存碎片**

### 复制(Copy)

> ![](.\img\249.jpg)
>
> ![](.\img\250.jpg)
>
> ![](.\img\251.jpg)
>
> * 将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。
> * **`总结`**：**不会有内存碎片，需要占双倍内存空间**

## 分代回收

> ![](.\img\252.jpg)
>
> ![](.\img\253.jpg)
>
> **回收流程**
>
> * 新创建的对象都被放在了**新生代的伊甸园**中
> * 当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做**Minor GC**
> * Minor GC会将**伊甸园和幸存区From**存活的对象先**复制**到**幸存区To**中，并让其**寿命+1**，再**交换两个幸存区**
> * Minor GC会触发**stop the world**，暂停其他用户线程，只让垃圾回收线程工作，等垃圾回收结束，用户线程才能恢复运行
> * 当幸存区的对象的**寿命超过某个阈值**(最大为15，4bit)，就会被**放入到老年代**中
> * 如果新生代和老年代中的内存都满了，就会先触发Minor GC，再触发**Full GC**，扫描新生代和老年代中所有不再使用的对象并回收

### 相关VM参数

|        含义        |                             参数                             |
| :----------------: | :----------------------------------------------------------: |
|     堆初始大小     |                             -Xms                             |
|     堆最大大小     |                 -Xmx 或 -XX:MaxHeapSize=size                 |
|     新生代大小     |      -Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )       |
| 幸存区比例（动态） | -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy |
|     幸存区比例     |                   -XX:SurvivorRatio=ratio                    |
|      晋升阈值      |              -XX:MaxTenuringThreshold=threshold              |
|      晋升详情      |                -XX:+PrintTenuringDistribution                |
|       GC详情       |               -XX:+PrintGCDetails -verbose:gc                |
| FullGC 前 MinorGC  |                  -XX:+ScavengeBeforeFullGC                   |

### GC分析

* 大对象处理策略
  * 当遇到一个**较大的对象**时，就算新生代的**伊甸园为空**，也**无法容纳该对象**时，会将该对象**直接晋升为老年代**
* 线程内存溢出
  * 某个线程的内存溢出而抛OOM，不会让其他的线程结束运行
  * 这时因为当一个**线程抛OOM异常后，它所占据的内存资源会全部被释放掉**，从而不会影响其他线程的运行，**进程依然正常**

## 垃圾回收器

> * **并行收集**：指多条垃圾收集线程并行工作，但此时**用户线程仍处于等待状态**
> * **并发收集**：指用户线程与垃圾收集线程**同时工作**(不一定是并行的可能会交替执行)。**用户程序在继续执行**，而垃圾收集程序运行在另一个CPU内核上
> * **吞吐量**：即CPU用于运行用户代码的时间与CPU总消耗时间的比值(吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间))

### 串行

> * 单线程
>
> * 内存较小，CPU核数较少
>
>   ![](.\img\254.jpg)
>
>   * **安全点**：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象。因为是串行，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞状态
>   * **Serial收集器**：是最基本的、发展历史最悠久的收集器。
>     * 特点：单线程、简单高效(与其他收集器的单线程相比)，采用**复制算法**。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束(Stop The World)
>   * **Serial Old收集器**：是Serial收集器的老年代版本
>     * 特点：同样是单线程收集器，采用**标记-整理算法**

### 吞吐量优先

> * 多线程
>
> * 堆内存较大，多核CPU
>
> * **单位时间内，STW(stop the world，停掉其他所有工作线程)时间最短**
>
> * **JDK1.8默认使用的垃圾回收器**
>
>   ![](.\img\255.jpg)
>
>   * **Parallel Scavenge收集器**：与吞吐量关系密切，故也称为吞吐量优先收集器
>     * 特点：属于新生代收集器，也是采用**复制算法**的收集器(用到了新生代的幸存区)，又是并行的多线程收集器，该收集器的目标是达到一个可控的吞吐量。
>     * Parallel Scavenge收集器使用两个参数控制吞吐量：
>       * XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间
>       * XX:GCRatio 直接设置吞吐量的大小
>   * **GC自适应调节策略**：Parallel Scavenge收集器可设置`-XX:+UseAdaptiveSizePolicy`参数。当开关**打开时不需要手动指定**新生代的大小(-Xmn)、Eden与Survivor区的比例(-XX:SuvivorRation)、晋升老年代对象年龄(-XX:PretenureSizeThreshold)等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的挺短时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略
>   * **Parallel Old收集器**：是Parallel Scavenge收集器的老年代版本
>     * 特点：多线程、采用**标记-整理算法**

### 响应时间优先(CMS)

> * 多线程
>
> * 堆内存较大，多核CPU
>
> * **尽可能让单次STW时间变短(尽量不影响其他线程运行)**
>
>   ![](.\img\256.jpg)
>
>   * **CMS收集器**：Concurrent Mark Sweep，一种以获取**最短回收停顿时间**为目标的老年代收集器
>     * 特点：基于**标记-清除**算法实现，并发收集、低停顿，但会产生内存碎片
>   * CMS收集器的运行过程分为下列4步：
>     * 初始标记：标记GC Root能直接到的对象。速度很快但是仍存在STW问题
>     * 并发标记：进行GC Root Tracing的过程，找出存活对象且用户线程可并发执行
>     * 重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象标记记录。仍存在STW问题
>     * 并发清除：对标记的对象进行清除回收

## Garbage First

> * JDK 9以后默认使用，而且替代了CMS收集器
>
> * 同时注重吞吐量和低延迟(响应时间)
>
> * 超大堆内存，会将堆内存**划分为多个大小相等的区域**
>
> * 整体上是**标记-整理**算法，两个**区域之间是复制算法**
>
>   <img src=".\img\257.jpg" style="zoom:50%;" />
>
>   > 新生代伊甸园垃圾回收---->内存不足，新生代回收+并发标记---->回收新生代伊甸园、幸存区、老年代内存

### 分区算法

> 分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个区间，方便控制GC产生的停顿时间

### Young Collection

> <img src=".\img\258.jpg" style="zoom:50%;" />
>
> * E：伊甸园
> * S：幸存区
> * O：老年代

### Young Collection+CM(并发标记)

> * 在Young GC时会**对GC Root进行初始标记**
>
> * 在老年代占用内存的比例达到阈值时(默认15%)，进行并发标记(不会STW)，阈值可以用户自定义`-XX:InitiatingHeapOccupancyPercent=xxx`
>
>   <img src=".\img\259.jpg" style="zoom:67%;" />

### Mixed Collection

> 会对E S O进行全面的回收：
>
> * 最终标记
> * 拷贝存活。
>
> `-XX:MaxGCPauseMills:xxx`用于指定最长的停顿时间
>
> <img src=".\img\260.jpg" style="zoom:67%;" />
>
> 为什么有的老年代被拷贝了，有的没拷贝？
>
> * 因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会**回收最有价值的老年代**（回收后，能够得到更多内存）

### Full GC

> G1在老年代内存不足时(老年代所占内存超过阈值)
>
> * 如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理
> * 如果垃圾产生速度快于垃圾回收速度，便会触发Full GC

## 垃圾回收调优

### 新生代调优

> * 新生代地特点
>   * 所有地new操作分配内存都是非常廉价地
>   * 死亡对象回收零代价
>   * 大部分对象用过即死
>   * Minor GC所用时间远小于Full GC
>
> > * 新生代内存越大越好吗？
> >   * 不是
> >     * 新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降
> >     * 新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费地时间会更长
> > * 新生代内存设置为：`并发量*(请求-响应)`的数据为宜
> > * 幸存区需要能够保证 **当前活跃对象+需要晋升的对象**
> > * 晋升阈值配置得当，让长时间存活的对象尽快晋升
> >   * `-XX:MaxTenuringThreshold=threshold`
> >   * `-XX:+PrintTenuringDistribution`

### 老年代调优

> * CMS的老年代内存越大越好
> * 观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3
>   * `-XX:CMSInitiatingOccupancyFraction=percent`

# 类加载

## 类加载阶段





## 类加载器





# 内存模型

